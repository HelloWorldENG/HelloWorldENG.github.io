<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon/apple-touch-icon-stars.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-32x32-stars.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-16x16-stars.png">
  <link rel="mask-icon" href="/images/favicon/logo.svg" color="#222">
  <meta name="google-site-verification" content="LLp7dDQLe1buCOlVDCZLpsjODRRMT963JQP6u0lgzTU">
  <meta name="msvalidate.01" content="C6F7DFBB3947DDB3A4DCE4F39DB51FA5">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css" integrity="sha256-/4UQcSmErDzPCMAiuOiWPVVsNN2s3ZY/NsmXNcj0IFc=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"helloworldeng.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":true,"version":"8.15.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"width":320},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="原先是为了方便我个人期末考的javaEE复习提纲，现在总结完传上来保存也是分享一下">
<meta property="og:type" content="article">
<meta property="og:title" content="javaEE总结">
<meta property="og:url" content="http://helloworldeng.github.io/2023/06/20/javaEE%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="HelloWorld">
<meta property="og:description" content="原先是为了方便我个人期末考的javaEE复习提纲，现在总结完传上来保存也是分享一下">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://helloworldeng.github.io/2023/06/20/javaEE%E6%80%BB%E7%BB%93/image-20230617161509927.png">
<meta property="og:image" content="http://helloworldeng.github.io/2023/06/20/javaEE%E6%80%BB%E7%BB%93/image-20230617164938224.png">
<meta property="og:image" content="http://helloworldeng.github.io/2023/06/20/javaEE%E6%80%BB%E7%BB%93/image-20230617215927814.png">
<meta property="og:image" content="http://helloworldeng.github.io/2023/06/20/javaEE%E6%80%BB%E7%BB%93/image-20230617230922631.png">
<meta property="og:image" content="http://helloworldeng.github.io/2023/06/20/javaEE%E6%80%BB%E7%BB%93/image-20230618112943893.png">
<meta property="og:image" content="http://helloworldeng.github.io/2023/06/20/javaEE%E6%80%BB%E7%BB%93/image-20230618113257850.png">
<meta property="og:image" content="http://helloworldeng.github.io/2023/06/20/javaEE%E6%80%BB%E7%BB%93/image-20230618134041622.png">
<meta property="og:image" content="http://helloworldeng.github.io/2023/06/20/javaEE%E6%80%BB%E7%BB%93/image-20230618141212966.png">
<meta property="og:image" content="http://helloworldeng.github.io/2023/06/20/javaEE%E6%80%BB%E7%BB%93/image-20230619014641653.png">
<meta property="og:image" content="http://helloworldeng.github.io/2023/06/20/javaEE%E6%80%BB%E7%BB%93/image-20230619023706905.png">
<meta property="og:image" content="http://helloworldeng.github.io/2023/06/20/javaEE%E6%80%BB%E7%BB%93/image-20230619143343932.png">
<meta property="og:image" content="http://helloworldeng.github.io/2023/06/20/javaEE%E6%80%BB%E7%BB%93/image-20230619144302671.png">
<meta property="og:image" content="http://helloworldeng.github.io/2023/06/20/javaEE%E6%80%BB%E7%BB%93/image-20230619150634196.png">
<meta property="og:image" content="http://helloworldeng.github.io/2023/06/20/javaEE%E6%80%BB%E7%BB%93/image-20230619155137039.png">
<meta property="og:image" content="http://helloworldeng.github.io/2023/06/20/javaEE%E6%80%BB%E7%BB%93/clip_image002.png">
<meta property="og:image" content="http://helloworldeng.github.io/2023/06/20/javaEE%E6%80%BB%E7%BB%93/295ddcc75ad2c2f7f9bfea66992216dc.png">
<meta property="article:published_time" content="2023-06-20T12:08:54.000Z">
<meta property="article:modified_time" content="2023-06-20T16:55:13.704Z">
<meta property="article:author" content="星星">
<meta property="article:tag" content="javaEE">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://helloworldeng.github.io/2023/06/20/javaEE%E6%80%BB%E7%BB%93/image-20230617161509927.png">


<link rel="canonical" href="http://helloworldeng.github.io/2023/06/20/javaEE%E6%80%BB%E7%BB%93/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://helloworldeng.github.io/2023/06/20/javaEE%E6%80%BB%E7%BB%93/","path":"2023/06/20/javaEE总结/","title":"javaEE总结"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>javaEE总结 | HelloWorld</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">HelloWorld</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80-Web-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8CHTTP-%E5%8D%8F%E8%AE%AE"><span class="nav-number">1.</span> <span class="nav-text">一. Web 服务器和HTTP 协议</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Web%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">1.1.</span> <span class="nav-text">1.Web服务器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84web%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">1.1.1.</span> <span class="nav-text">常见的web服务器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#web%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">1.1.2.</span> <span class="nav-text">web服务器工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#web%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8Cweb%E5%BA%94%E7%94%A8%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">1.1.3.</span> <span class="nav-text">web服务器和web应用的关系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-tomcat-%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">1.2.</span> <span class="nav-text">2.tomcat 服务器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E7%AB%AF%E5%8F%A3%E5%8F%B78080"><span class="nav-number">1.2.1.</span> <span class="nav-text">默认端口号8080</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#conf-x2F-server-xml%E4%BF%AE%E6%94%B9%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="nav-number">1.2.2.</span> <span class="nav-text">conf&#x2F;server.xml修改端口号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tomcat%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A1%B9%E7%9B%AE%E7%9A%84%E9%83%A8%E7%BD%B2%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">1.2.3.</span> <span class="nav-text">tomcat服务器项目的部署的两种方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-HTTP%E5%8D%8F%E8%AE%AE-%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE"><span class="nav-number">1.3.</span> <span class="nav-text">3.HTTP协议(超文本传输协议)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#http%E5%9F%BA%E4%BA%8ETCP-x2F-IP%E5%8D%8F%E8%AE%AE%EF%BC%8C%E4%BC%A0%E8%BE%93%E5%B1%82%E5%9F%BA%E4%BA%8E%E5%8F%AF%E9%9D%A0%E7%9A%84TCP%E5%8D%8F%E8%AE%AE-%E9%BB%98%E8%AE%A4%E7%AB%AF%E5%8F%A3%E5%8F%B7-80"><span class="nav-number">1.3.1.</span> <span class="nav-text">http基于TCP&#x2F;IP协议，传输层基于可靠的TCP协议,默认端口号 80</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#https-%E9%BB%98%E8%AE%A4%E7%AB%AF%E5%8F%A3%E5%8F%B7443"><span class="nav-number">1.3.2.</span> <span class="nav-text">https 默认端口号443</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP%E3%80%81HTML%E3%80%81HTTPS%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="nav-number">1.3.3.</span> <span class="nav-text">HTTP、HTML、HTTPS的区别和联系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-HTTP%E7%9A%84%E6%8A%A5%E6%96%87%E7%B1%BB%E5%9E%8B%EF%BC%9A%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87-%E5%BA%94%E7%AD%94-%E5%93%8D%E5%BA%94-%E6%8A%A5%E6%96%87"><span class="nav-number">1.4.</span> <span class="nav-text">4.HTTP的报文类型：请求报文 应答(响应)报文</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84%EF%BC%9A%E5%A4%B4%E9%83%A8%E5%92%8C%E4%B8%BB%E4%BD%93"><span class="nav-number">1.4.1.</span> <span class="nav-text">HTTP报文结构：头部和主体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87"><span class="nav-number">1.4.2.</span> <span class="nav-text">请求报文</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">请求类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#get%E5%92%8Cpost%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">get和post区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP-%E5%8D%8F%E8%AE%AE%E4%B8%AD%E8%A7%84%E5%AE%9A-POST-%E6%8F%90%E4%BA%A4%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BF%85%E9%A1%BB%E5%9C%A8-body-%E9%83%A8%E5%88%86"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">HTTP 协议中规定 POST 提交的数据必须在 body 部分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#post%E5%86%85%E5%AE%B9%E7%B1%BB%E5%9E%8BContent-type"><span class="nav-number">1.4.2.4.</span> <span class="nav-text">post内容类型Content-type</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%AD%94%E6%8A%A5%E6%96%87"><span class="nav-number">1.4.3.</span> <span class="nav-text">应答报文</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">常见的状态码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#URL"><span class="nav-number">1.4.4.</span> <span class="nav-text">URL</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#url%E5%AD%97%E6%AE%B5%E5%90%AB%E4%B9%89"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">url字段含义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#url%E4%BC%A0%E5%8F%82"><span class="nav-number">1.4.4.2.</span> <span class="nav-text">url传参</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Maven"><span class="nav-number">1.4.5.</span> <span class="nav-text">Maven</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">1.4.5.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Maven-%E7%9A%84%E2%BD%AC%E6%A0%87"><span class="nav-number">1.4.5.2.</span> <span class="nav-text">Maven 的⽬标</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pom-xml%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">1.4.5.3.</span> <span class="nav-text">pom.xml文件的作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#maven%E4%BB%93%E5%BA%93"><span class="nav-number">1.4.5.4.</span> <span class="nav-text">maven仓库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#maven%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-number">1.4.5.5.</span> <span class="nav-text">maven常用命令</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C-Servlet-%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-number">2.</span> <span class="nav-text">二. Servlet 和过滤器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Servlet%E5%9F%BA%E7%A1%80"><span class="nav-number">2.1.</span> <span class="nav-text">1.Servlet基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Servlet-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">2.1.1.</span> <span class="nav-text">1.Servlet 是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-servlet%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD"><span class="nav-number">2.1.2.</span> <span class="nav-text">2.servlet的主要功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E9%83%A8%E7%BD%B2%E8%BF%90%E8%A1%8C"><span class="nav-number">2.1.3.</span> <span class="nav-text">3.部署运行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84"><span class="nav-number">2.1.4.</span> <span class="nav-text">4.代码结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%A4%84%E7%90%86Http%E8%AF%B7%E6%B1%82"><span class="nav-number">2.2.</span> <span class="nav-text">2.处理Http请求</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-servlet%E6%98%A0%E5%B0%84%E5%88%B0-url-%E5%9C%B0%E5%9D%80"><span class="nav-number">2.2.1.</span> <span class="nav-text">1.servlet映射到 url 地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%8E%B7%E5%8F%96%E5%8F%82%E6%95%B0-getParameter"><span class="nav-number">2.2.2.</span> <span class="nav-text">2.获取参数-getParameter()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98"><span class="nav-number">2.2.3.</span> <span class="nav-text">3.中文乱码问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-servlet-%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C"><span class="nav-number">2.2.4.</span> <span class="nav-text">4.servlet 返回结果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-servlet%E5%A4%84%E7%90%86-HTTP-%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E8%AF%B7%E6%B1%82"><span class="nav-number">2.2.5.</span> <span class="nav-text">5.servlet处理 HTTP 不同类型请求</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Servlet-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">2.3.</span> <span class="nav-text">3.Servlet 的生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%9B%9B%E4%B8%AA%E5%91%A8%E6%9C%9F"><span class="nav-number">2.3.1.</span> <span class="nav-text">1.四个周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Servlet%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">2.3.2.</span> <span class="nav-text">2.Servlet处理请求的过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E8%BF%87%E6%BB%A4%E5%99%A8FIlter"><span class="nav-number">2.4.</span> <span class="nav-text">4.过滤器FIlter</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E8%BF%87%E6%BB%A4%E5%99%A8%E7%94%A8%E9%80%94%E5%92%8C%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">2.4.1.</span> <span class="nav-text">1.过滤器用途和工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">2.4.2.</span> <span class="nav-text">2.应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E9%83%A8%E7%BD%B2"><span class="nav-number">2.4.3.</span> <span class="nav-text">3.过滤器的部署</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E7%A0%81%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-number">2.4.3.1.</span> <span class="nav-text">编码过滤器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-number">2.4.3.2.</span> <span class="nav-text">用户权限过滤器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE"><span class="nav-number">2.4.4.</span> <span class="nav-text">4.过滤器链</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89-Spring-IOC-%E5%92%8C%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.</span> <span class="nav-text">三. Spring IOC 和单例设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Spring-%E7%9A%84%E6%A0%B8%E5%BF%83IOC-%E5%92%8C-AOP"><span class="nav-number">3.1.</span> <span class="nav-text">1.Spring 的核心IOC 和 AOP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-IOC-%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B3%A8%E5%85%A5%E5%92%8C%E8%A3%85%E9%85%8D"><span class="nav-number">3.2.</span> <span class="nav-text">2.IOC 容器中对象的注入和装配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E-xml"><span class="nav-number">3.2.1.</span> <span class="nav-text">基于 xml</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3"><span class="nav-number">3.2.2.</span> <span class="nav-text">基于注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E-Java-%E9%85%8D%E7%BD%AE%E7%B1%BB"><span class="nav-number">3.2.3.</span> <span class="nav-text">基于 Java 配置类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.3.</span> <span class="nav-text">3.单例设计模式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B-SpringBoot-%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE"><span class="nav-number">4.</span> <span class="nav-text">四. SpringBoot 核心配置</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-SpringBoot-%E6%A1%86%E6%9E%B6%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">4.1.</span> <span class="nav-text">1.SpringBoot 框架的特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-springboot-%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84"><span class="nav-number">4.2.</span> <span class="nav-text">2.springboot 项目的代码结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-SpringBoot-%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="nav-number">4.3.</span> <span class="nav-text">3.SpringBoot 的配置文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#application-properties"><span class="nav-number">4.3.1.</span> <span class="nav-text">application.properties</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#application-yaml"><span class="nav-number">4.3.2.</span> <span class="nav-text">application.yaml</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E5%B1%9E%E6%80%A7%E5%80%BC%E7%9A%84%E6%B3%A8%E5%85%A5"><span class="nav-number">4.4.</span> <span class="nav-text">4.配置文件的属性值的注入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ConfigurationProperties-%E6%B3%A8%E5%85%A5%E5%88%B0%E6%95%B4%E4%B8%AA%E7%B1%BB"><span class="nav-number">4.4.1.</span> <span class="nav-text">@ConfigurationProperties(注入到整个类)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Value-%E5%8D%95%E4%B8%AA%E5%80%BC%E7%9A%84%E6%B3%A8%E5%85%A5"><span class="nav-number">4.4.2.</span> <span class="nav-text">@Value()单个值的注入</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94-SpringBoot-Web-%E5%B1%82"><span class="nav-number">5.</span> <span class="nav-text">五. SpringBoot Web 层</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%98%A0%E5%B0%84%E5%88%B0-URL"><span class="nav-number">5.1.</span> <span class="nav-text">1.映射到 URL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C"><span class="nav-number">5.2.</span> <span class="nav-text">2.返回结果</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%8E%A7%E5%88%B6%E5%99%A8%E5%92%8CServlet%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.3.</span> <span class="nav-text">3.控制器和Servlet的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Controller%E5%92%8C-RestController%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.4.</span> <span class="nav-text">4.@Controller和@RestController的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E5%89%8D%E7%AB%AF%E5%8F%82%E6%95%B0%E7%9A%84%E8%8E%B7%E5%8F%96"><span class="nav-number">5.5.</span> <span class="nav-text">5.前端参数的获取</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%8D%95%E4%B8%AA%E5%8F%82%E6%95%B0-RequestParam"><span class="nav-number">5.5.1.</span> <span class="nav-text">获取单个参数--@RequestParam</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0-PathVariable"><span class="nav-number">5.5.2.</span> <span class="nav-text">获取路径参数--@PathVariable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96JSON%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%8F%82%E6%95%B0%E5%80%BC-RequestBody"><span class="nav-number">5.5.3.</span> <span class="nav-text">获取JSON格式的参数值--@RequestBody</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E5%8F%91%E9%80%81%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE"><span class="nav-number">5.6.</span> <span class="nav-text">6.发送响应数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ResponseBody"><span class="nav-number">5.6.1.</span> <span class="nav-text">@ResponseBody</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C"><span class="nav-number">5.7.</span> <span class="nav-text">7.数据校验</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Valid-POJO%E7%B1%BB%E6%A0%A1%E9%AA%8C"><span class="nav-number">5.7.1.</span> <span class="nav-text">@Valid-POJO类校验</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Validated-%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E5%90%88%E6%B3%95%E6%80%A7%E6%A0%A1%E9%AA%8C"><span class="nav-number">5.7.2.</span> <span class="nav-text">@Validated-方法参数合法性校验</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Valid%E5%92%8C-Validated%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.7.3.</span> <span class="nav-text">@Valid和@Validated的区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD-Mybatis-%E2%80%93-ORM"><span class="nav-number">6.</span> <span class="nav-text">六. Mybatis – ORM</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-ORM%EF%BC%88Object-Relational-Mapping%EF%BC%89"><span class="nav-number">6.1.</span> <span class="nav-text">1.ORM（Object Relational Mapping）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Mybatis%E5%92%8CORM"><span class="nav-number">6.2.</span> <span class="nav-text">2.Mybatis和ORM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-MySQL%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2SQL"><span class="nav-number">6.3.</span> <span class="nav-text">3.MySQL数据查询分页查询SQL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#limit"><span class="nav-number">6.3.1.</span> <span class="nav-text">limit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%E5%89%8D%E7%AB%AF%E9%9C%80%E8%A6%81%E4%BC%A0%E9%80%92%E4%B8%A4%E4%B8%AA%E5%8F%82%E6%95%B0"><span class="nav-number">6.3.2.</span> <span class="nav-text">分页查询前端需要传递两个参数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Mapper-%E5%B1%82%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BC%96%E5%86%99-Mapper"><span class="nav-number">6.4.</span> <span class="nav-text">4.Mapper 层代码的编写@Mapper</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-Mybatis-%E6%95%B4%E5%90%88%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">6.5.</span> <span class="nav-text">5.Mybatis 整合的两种方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3-1"><span class="nav-number">6.5.1.</span> <span class="nav-text">基于注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8EXML%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6"><span class="nav-number">6.5.2.</span> <span class="nav-text">基于XML映射文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-Mybatis-%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BC%A0%E5%8F%82"><span class="nav-number">6.6.</span> <span class="nav-text">6.Mybatis 接口的传参</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%8D%95%E4%B8%AA%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="nav-number">6.6.1.</span> <span class="nav-text">1. 单个参数传递</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%BD%BF%E7%94%A8-param%E4%B8%BA%E5%8F%82%E6%95%B0%E5%91%BD%E5%90%8D%E4%BC%A0%E9%80%92%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0"><span class="nav-number">6.6.2.</span> <span class="nav-text">2. 使用@param为参数命名传递多个参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E4%BD%BF%E7%94%A8Java%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%82%E6%95%B0"><span class="nav-number">6.6.3.</span> <span class="nav-text">3. 使用Java对象作为方法的参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E4%BD%BF%E7%94%A8%E4%BD%8D%E7%BD%AE%E4%BC%A0%E5%8F%82"><span class="nav-number">6.6.4.</span> <span class="nav-text">4. 使用位置传参</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E4%BD%BF%E7%94%A8map%E4%BC%A0%E5%8F%82"><span class="nav-number">6.6.5.</span> <span class="nav-text">5. 使用map传参</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E5%9F%BA%E4%BA%8Emybatis%E7%9A%84%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2"><span class="nav-number">6.7.</span> <span class="nav-text">7.基于mybatis的模糊查询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E5%9F%BA%E4%BA%8EMybatis%E7%9A%84%E5%8A%A8%E6%80%81%E5%A4%9A%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2"><span class="nav-number">6.8.</span> <span class="nav-text">8.基于Mybatis的动态多条件查询</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#if"><span class="nav-number">6.8.1.</span> <span class="nav-text">if</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#where"><span class="nav-number">6.8.2.</span> <span class="nav-text">where</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set"><span class="nav-number">6.8.3.</span> <span class="nav-text">set</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#foreach"><span class="nav-number">6.8.4.</span> <span class="nav-text">foreach</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SQL%E2%BD%9A%E6%AE%B5-sql"><span class="nav-number">6.8.5.</span> <span class="nav-text">SQL⽚段 sql</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#script"><span class="nav-number">6.8.6.</span> <span class="nav-text">script</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-Mybatis-plus"><span class="nav-number">6.9.</span> <span class="nav-text">9.Mybatis-plus</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB"><span class="nav-number">6.10.</span> <span class="nav-text">10.对象关联关系</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%83-Redis-%E7%BC%93%E5%AD%98%E5%92%8CRabbitMQ"><span class="nav-number">7.</span> <span class="nav-text">七. Redis 缓存和RabbitMQ</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Redis"><span class="nav-number">7.1.</span> <span class="nav-text">1.Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AB%AF%E5%8F%A3%E5%8F%B76379"><span class="nav-number">7.1.1.</span> <span class="nav-text">端口号6379</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">7.1.2.</span> <span class="nav-text">redis的实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis%E6%95%B4%E5%90%88Springboot%E4%B8%BB%E8%A6%81%E6%B3%A8%E8%A7%A3"><span class="nav-number">7.1.3.</span> <span class="nav-text">redis整合Springboot主要注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E5%AE%9E%E7%8E%B0%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-number">7.1.4.</span> <span class="nav-text">Redis实现和数据库的数据一致性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-rabbitMQ"><span class="nav-number">7.2.</span> <span class="nav-text">2.rabbitMQ</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">7.2.1.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E9%A1%B5%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AB%AF%E5%8F%A3%E5%8F%B7%EF%BC%9A15672"><span class="nav-number">7.2.2.</span> <span class="nav-text">网页客户端端口号：15672</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E7%AB%AF%E5%8F%A3%E5%8F%B7%EF%BC%9A5672"><span class="nav-number">7.2.3.</span> <span class="nav-text">配置端口号：5672</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rabbitMQ%E7%9A%84%E5%87%A0%E4%B8%AA%E6%A6%82%E5%BF%B5"><span class="nav-number">7.2.4.</span> <span class="nav-text">rabbitMQ的几个概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rabbitMQ%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="nav-number">7.2.5.</span> <span class="nav-text">rabbitMQ的工作模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="nav-number">7.2.6.</span> <span class="nav-text">常用的消息队列中间件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AB-%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="nav-number">8.</span> <span class="nav-text">八. 任务管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#cron%E6%97%B6%E9%97%B4%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">8.1.</span> <span class="nav-text">cron时间表达式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B9%9D-Java-EE%E5%90%8E%E7%AB%AF%E5%88%86%E5%B1%82%E8%AE%BE%E8%AE%A1"><span class="nav-number">9.</span> <span class="nav-text">九. Java EE后端分层设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MVC%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%B5%81%E7%A8%8B"><span class="nav-number">9.1.</span> <span class="nav-text">MVC设计模式流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E6%A8%A1%E5%BC%8F%E7%89%B9%E7%82%B9%EF%BC%8C%E5%92%8C%E4%BC%A0%E7%BB%9F%E5%90%8E%E7%AB%AF%E6%B8%B2%E6%9F%93%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">9.2.</span> <span class="nav-text">前后端分离模式特点，和传统后端渲染模式的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Service%E3%80%81-Transactional"><span class="nav-number">9.3.</span> <span class="nav-text">@Service、@Transactional</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5DTO%E3%80%81VO%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">9.4.</span> <span class="nav-text">设计的基本概念DTO、VO的作用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81-SpringSecurity"><span class="nav-number">10.</span> <span class="nav-text">十. SpringSecurity</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-SpringSecurity-%E7%9A%84%E4%B8%A4%E5%A4%A7%E5%8A%9F%E8%83%BD"><span class="nav-number">10.1.</span> <span class="nav-text">1.SpringSecurity 的两大功能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83%E6%B6%89%E5%8F%8A%E5%88%B0%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE"><span class="nav-number">10.2.</span> <span class="nav-text">2.认证和授权涉及到哪些数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E7%94%A8%E6%88%B7-%E8%A7%92%E8%89%B2-%E6%9D%83%E9%99%90%E6%98%AF%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%EF%BC%9F%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1%E6%95%B0%E6%8D%AE%E8%A1%A8"><span class="nav-number">10.3.</span> <span class="nav-text">3.用户-角色-权限是什么关系？怎么设计数据表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-springsecurity-%E4%B8%AD%EF%BC%8C%E8%A7%92%E8%89%B2%E5%92%8C%E6%9D%83%E9%99%90%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB"><span class="nav-number">10.4.</span> <span class="nav-text">4.springsecurity 中，角色和权限有哪些区别</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="星星"
      src="/images/avatar/rick.jpg">
  <p class="site-author-name" itemprop="name">星星</p>
  <div class="site-description" itemprop="description">坚持输出文字垃圾</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/HelloWorldENG" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;HelloWorldENG" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2972784944@qq.com" title="E-Mail → mailto:2972784944@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/275001902?spm_id_from=333.1007.0.0" title="Bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;275001902?spm_id_from&#x3D;333.1007.0.0" rel="noopener me" target="_blank"><i class="fab fa-bilibili fa-fw"></i></a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    
    <!--球状标签云-->
    
        <script type="text/javascript" charset="utf-8" src="/js/tagcloud.js"></script>
        <script type="text/javascript" charset="utf-8" src="/js/tagcanvas.js"></script>
        <div class="widget-wrap">
          <div id="myCanvasContainer" class="widget tagcloud" style="height: 100px;width: 100px;margin: 0 auto;">
              <canvas width="250" height="250" id="resCanvas" style="width:100%">
                 <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo%E5%8D%9A%E5%AE%A2/" rel="tag">Hexo博客</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MarkDown/" rel="tag">MarkDown</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Typora/" rel="tag">Typora</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bug/" rel="tag">bug</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cursor/" rel="tag">cursor</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javaEE/" rel="tag">javaEE</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a><span class="tag-list-count">1</span></li></ul>
              </canvas>
          </div>
        </div>
      
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://helloworldeng.github.io/2023/06/20/javaEE%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar/rick.jpg">
      <meta itemprop="name" content="星星">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HelloWorld">
      <meta itemprop="description" content="坚持输出文字垃圾">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="javaEE总结 | HelloWorld">
      <meta itemprop="description" content="原先是为了方便我个人期末考的javaEE复习提纲，现在总结完传上来保存也是分享一下">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          javaEE总结
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-06-20 20:08:54" itemprop="dateCreated datePublished" datetime="2023-06-20T20:08:54+08:00">2023-06-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-21 00:55:13" itemprop="dateModified" datetime="2023-06-21T00:55:13+08:00">2023-06-21</time>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="javaEE总结" href="/2023/06/20/javaEE%E6%80%BB%E7%BB%93/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::e18dc55799ec4639f05c0404063ad9c9" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>19k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:10</span>
    </span>
</div>

            <div class="post-description">原先是为了方便我个人期末考的javaEE复习提纲，现在总结完传上来保存也是分享一下</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="一-Web-服务器和HTTP-协议"><a href="#一-Web-服务器和HTTP-协议" class="headerlink" title="一. Web 服务器和HTTP 协议"></a>一. Web 服务器和HTTP 协议</h1><h2 id="1-Web服务器"><a href="#1-Web服务器" class="headerlink" title="1.Web服务器"></a>1.Web服务器</h2><h3 id="常见的web服务器"><a href="#常见的web服务器" class="headerlink" title="常见的web服务器"></a>常见的web服务器</h3><p>（1）Apache。Apache仍然是世界上⽤的最多的Web服务器，市场占有率达60%左右，可以运⾏在所有的Unix、windows、Linux平台上，使⽤PHP语⾔开发Web⽹站通常需要部署到Apache服务器。 </p>
<p>(2) IIS。全程为Internet Information Services （IIS），由微软公司开发，也是目前最流⾏的Web服务器产品之 ⼀。IIS提供了⼀个图形界⾯的管理⼯具 ，称为Internet服务，可⽤于监视配置和控制Internet服务，⽀持asp 、sp.net等多种开发语⾔。</p>
<p>(3) Nginx，发⾳为「engine X」，是⼀个基于异步框架的⾼性能Web服务器，通常⽤作反向代理、负载均衡器和 HTTP缓存。Nginx由俄罗斯程序员伊⼽爾·賽索耶夫 （Игорь Сысоев）于2004开发发布，2019年被F5⽹络公司以 6.7亿美元收购，Nginx在⾼并发下能保持低资源低消耗⾼性能，⽬前是⽹络中应⽤⼴泛的Web服务器之⼀。 </p>
<p>(4) Apache Tomcat，是⼀个⾯向中⼩型系统的Web服务器，是由Apache软件基⾦会属下Jakarta项⽬ 开发的 Servlet 容器，按照Sun Microsystems 提供的技术规范，实现了对Servlet和JavaServer Page(JSP)的支持。Tomcat往往作为Java Web开发初学者常⽤的服务器</p>
<h3 id="web服务器工作原理"><a href="#web服务器工作原理" class="headerlink" title="web服务器工作原理"></a>web服务器工作原理</h3><p>Web也称为万维⽹，World Wide Web，是指通过互联⽹访问的，由许多相互链接的HTML⻚⾯组成的⼀个⽹络 系统。Web服务器通常则指提供⽹站服务的⼀种运⾏在后台的应⽤程序。</p>
<h3 id="web服务器和web应用的关系"><a href="#web服务器和web应用的关系" class="headerlink" title="web服务器和web应用的关系"></a>web服务器和web应用的关系</h3><p>**(from 网络)**Web服务器实现了HTTP协议的服务器，监听端口，接受客户端建立连接的请求，捐接收数据，并把接收到的HTTP请求通过类似CGI，WSGI，Servlet的接口交给应用程序处理，而应用程序处理后的输出交给 Web服务器，由Web服务器通过连接发送给客户端</p>
<p>**(from pdf)**Web系统通常包含前端和后端两部分：(1)前端由浏览器组成， 负责解析HTML⻚⾯的代码以及运⾏javascript脚本程序，完成⻚⾯渲染；(2)后端则负责处理前端发送的Http请 求，将数据或者⽹⻚及其资源⽂件发回给前端。</p>
<h2 id="2-tomcat-服务器"><a href="#2-tomcat-服务器" class="headerlink" title="2.tomcat 服务器"></a>2.tomcat 服务器</h2><h3 id="默认端口号8080"><a href="#默认端口号8080" class="headerlink" title="默认端口号8080"></a>默认端口号8080</h3><h3 id="conf-x2F-server-xml修改端口号"><a href="#conf-x2F-server-xml修改端口号" class="headerlink" title="conf&#x2F;server.xml修改端口号"></a>conf&#x2F;server.xml修改端口号</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置tomcat服务器端⼝号,默认为8080 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span> <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--  客户端可以通过8009端⼝号,使⽤AJP协议访问Tomcat --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8009&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;AJP/1.3&quot;</span> <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /</span></span><br></pre></td></tr></table></figure>

<h3 id="tomcat服务器项目的部署的两种方式"><a href="#tomcat服务器项目的部署的两种方式" class="headerlink" title="tomcat服务器项目的部署的两种方式"></a>tomcat服务器项目的部署的两种方式</h3><p>1.编译好的项目文件复制到webapps目录下</p>
<p>2.将项目打包成war压缩文件， 复制到webapps目录</p>
<h2 id="3-HTTP协议-超文本传输协议"><a href="#3-HTTP协议-超文本传输协议" class="headerlink" title="3.HTTP协议(超文本传输协议)"></a>3.HTTP协议(超文本传输协议)</h2><h3 id="http基于TCP-x2F-IP协议，传输层基于可靠的TCP协议-默认端口号-80"><a href="#http基于TCP-x2F-IP协议，传输层基于可靠的TCP协议-默认端口号-80" class="headerlink" title="http基于TCP&#x2F;IP协议，传输层基于可靠的TCP协议,默认端口号 80"></a>http基于TCP&#x2F;IP协议，传输层基于可靠的TCP协议,默认端口号 80</h3><p>可以⽤来传输HTML⽂件、图⽚⽂件和查询结果等。</p>
<h3 id="https-默认端口号443"><a href="#https-默认端口号443" class="headerlink" title="https 默认端口号443"></a>https 默认端口号443</h3><h3 id="HTTP、HTML、HTTPS的区别和联系"><a href="#HTTP、HTML、HTTPS的区别和联系" class="headerlink" title="HTTP、HTML、HTTPS的区别和联系"></a>HTTP、HTML、HTTPS的区别和联系</h3><p><strong>HTTP协议被用于在Web浏览器和网站服务器之间传递信息。HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此HTTP协议不适合传输一些敏感信息，比如信用卡号、密码等。</strong></p>
<p>  为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS。为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p>
<p>  <strong>HTTPS和HTTP的区别主要为以下四点：</strong></p>
<p>  1.https协议需要到ca申请证书，一般免费证书很少，需要交费。</p>
<p>  2.http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。</p>
<p>  3.http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p>
<p>  4.http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络，比http协议安全。</p>
<p> HTML是页面描述语言</p>
<h2 id="4-HTTP的报文类型：请求报文-应答-响应-报文"><a href="#4-HTTP的报文类型：请求报文-应答-响应-报文" class="headerlink" title="4.HTTP的报文类型：请求报文 应答(响应)报文"></a>4.HTTP的报文类型：请求报文 应答(响应)报文</h2><h3 id="HTTP报文结构：头部和主体"><a href="#HTTP报文结构：头部和主体" class="headerlink" title="HTTP报文结构：头部和主体"></a>HTTP报文结构：头部和主体</h3><p>HTTP 协议是以 ASCII 码传输，建⽴在 TCP&#x2F;IP 协议之上的应⽤层规范。规范把 HTTP 请求分为三个部分：状态 ⾏、请求头、消息主体。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">method</span>&gt;</span> <span class="tag">&lt;<span class="name">request-URL</span>&gt;</span> <span class="tag">&lt;<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">headers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">entity-body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/06/20/javaEE%E6%80%BB%E7%BB%93/image-20230617161509927.png" alt="image-20230617161509927"></p>
<h3 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h3><h4 id="请求类型"><a href="#请求类型" class="headerlink" title="请求类型"></a>请求类型</h4><p>HTTP 定义了与服务器交互的不同⽅法，最基本的⽅法有4种，分别是GET，POST，PUT，DELETE。URL全称是 资源描述符，⼀个URL地址，它⽤于描述⼀个⽹络上的资源，对应着对资源的查，增，改，删4个操作。</p>
<p><img src="/2023/06/20/javaEE%E6%80%BB%E7%BB%93/image-20230617164938224.png" alt="image-20230617164938224"></p>
<p>重点关注 GET,POST,PUT,DELETE,HEAD。</p>
<h4 id="get和post区别"><a href="#get和post区别" class="headerlink" title="get和post区别"></a>get和post区别</h4><p>GET 可提交的数据量受到URL⻓度的限制，HTTP 协议规范没有对 URL ⻓度进⾏限制。这个限制是特定的浏览器及服务器对它的限制。</p>
<p>理论上讲，POST 是没有⼤⼩限制的，HTTP 协议规范也没有进⾏⼤⼩限制，出于安全考虑，服务器软件在实现时会做⼀定限制。</p>
<p>GET 和 POST 数据内容是⼀模⼀样的，只是位置不同，⼀个在 URL  ⾥，⼀个在 HTTP 包的包体⾥。</p>
<h4 id="HTTP-协议中规定-POST-提交的数据必须在-body-部分"><a href="#HTTP-协议中规定-POST-提交的数据必须在-body-部分" class="headerlink" title="HTTP 协议中规定 POST 提交的数据必须在 body 部分"></a>HTTP 协议中规定 POST 提交的数据必须在 body 部分</h4><h4 id="post内容类型Content-type"><a href="#post内容类型Content-type" class="headerlink" title="post内容类型Content-type"></a>post内容类型Content-type</h4><ol>
<li><p>application&#x2F;x-www-form-urlencoded</p>
<p>最常⻅的 POST 数据提交⽅式。浏览器的原⽣表单，如果不设置 enctype 属性，那么最终就会以这种⽅式提交数据。body 当中的内容和 GET 请求是完全相同的。</p>
</li>
<li><p>multipart&#x2F;form-data</p>
<p>这⼜是⼀个常⻅的 POST 数据提交的⽅式。我们使⽤表单上传⽂件时，必须让  multipart&#x2F;form-data 。</p>
</li>
<li><p><strong>application&#x2F;json</strong></p>
<p><strong>JSON数据类型，用于传输结构化的数据。</strong></p>
</li>
<li><p>text&#x2F;xml</p>
<p>XML数据类型，用于传输可扩展标记语言（Extensible Markup Language）数据。</p>
</li>
<li><p>application&#x2F;x-protobuf</p>
<p>用于传输Protocol Buffers（简称Protobuf）数据。⼆进制格式</p>
</li>
</ol>
<p><strong>服务器根据 Content-Type 和 Content-Encoding 解析请求</strong></p>
<h3 id="应答报文"><a href="#应答报文" class="headerlink" title="应答报文"></a>应答报文</h3><p>状态行、响应头(Response Header)、 响应正⽂</p>
<h4 id="常见的状态码"><a href="#常见的状态码" class="headerlink" title="常见的状态码"></a>常见的状态码</h4><ul>
<li><strong>200 OK 客户端请求成功</strong> </li>
<li>301 Moved Permanently 请求永久重定向 </li>
<li>302 Moved Temporarily 请求临时重定向 </li>
<li><strong>304 Not Modified 文件未修改，可以直接使用缓存的文件。</strong> </li>
<li>400 Bad Request 由于客户端请求有语法错误，不能被服务器所理解。 </li>
<li>401 Unauthorized 请求未经授权。这个状态代码必须和WWW-Authenticate报头域⼀起使⽤ </li>
<li><strong>403 Forbidden 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正⽂中给出不提供服务的原因</strong> </li>
<li><strong>404 Not Found 请求的资源不存在，例如，输⼊了错误的URL</strong> </li>
<li><strong>500 Internal Server Error 服务器发⽣不可预期的错误，导致⽆法完成客户端的请求。</strong> </li>
<li>503 Service Unavailable 服务器当前不能够处理客户端的请求，在⼀段时间之后，服务器可能会恢复正常。</li>
</ul>
<h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><p>URL全称是资源描述符，⼀个URL地址，它⽤于描述⼀个⽹络上的资源</p>
<h4 id="url字段含义"><a href="#url字段含义" class="headerlink" title="url字段含义"></a>url字段含义</h4><p>示例：<a target="_blank" rel="noopener" href="http://www.testjava.com:9000/">http://www.testjava.com:9000/</a> input&#x2F;test?a&#x3D;3&amp;b&#x3D;5….</p>
<p>在URL（Uniform Resource Locator）中，各个字段的含义如下：</p>
<ol>
<li>协议（Protocol）：在这个示例中，协议为HTTP（Hypertext Transfer Protocol），它定义了浏览器和服务器之间进行通信的规则。</li>
<li>域名（Domain Name）：在这个示例中，域名为”<a target="_blank" rel="noopener" href="http://www.testjava.com".它是用于识别和定位网站的字符串,通常由多个部分组成,例如"www"表示主机,"testjava"表示域名的名称,而"com"表示顶级域./">www.testjava.com&quot;。它是用于识别和定位网站的字符串，通常由多个部分组成，例如&quot;www&quot;表示主机，&quot;testjava&quot;表示域名的名称，而&quot;com&quot;表示顶级域。</a></li>
<li>端口（Port）：在这个示例中，端口号为9000。它用于标识服务器上的特定服务。HTTP协议的默认端口是80，但在这个URL中，使用了非默认的端口号9000。</li>
<li>路径（Path）：在这个示例中，路径为”&#x2F;input&#x2F;test”。它指定了服务器上资源的具体位置或路径。当浏览器发送请求时，服务器将根据路径来定位所需的资源。</li>
<li>查询参数（Query Parameters）：在这个示例中，查询参数为”a&#x3D;3&amp;b&#x3D;5”。查询参数用于向服务器传递额外的信息或数据。它们位于URL路径之后，以问号（?）分隔，多个参数之间使用和号（&amp;）分隔。在这个示例中，参数”a”的值为3，参数”b”的值为5。</li>
</ol>
<h4 id="url传参"><a href="#url传参" class="headerlink" title="url传参"></a>url传参</h4><p>对于数据的传递，HTTP协议提供了两种常见的方式：</p>
<ol>
<li><p>数据放在URL中的查询参数：就像上述示例中的查询参数一样，可以将数据直接放在URL中作为查询参数的一部分。这种方式适用于较小的数据，对于敏感数据或需要保密的数据不太安全。</p>
</li>
<li><p>数据放在请求的主体中（Body）：对于较大的数据或需要保密的数据，可以将数据放在请求的主体中。这通常用于HTTP的POST请求。数据可以使用不同的格式，例如表单数据（form data）、JSON数据等。在这种情况下，请求头（Headers）中通常会包含一些描述数据的信息，例如Content-Type来指定主体数据的格式。</p>
</li>
</ol>
<p>需要根据实际情况选择将数据放在URL的查询参数中还是请求主体中，通常取决于数据的大小、安全性需求和服务器端的处理方式。</p>
<h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Maven 是⼀款基于 Java 平台的项⽬管理和整合⼯具，它将项⽬的开发和管理过程抽象成⼀个项⽬对象模型 （POM）。开发⼈员只需要做⼀些简单的配置，Maven 就可以⾃动完成项⽬的编译、测试、打包、发布以及部署 等⼯作。 </p>
<p>Maven 是使⽤ Java 语⾔编写的，因此它和 Java ⼀样具有跨平台性，这意味着⽆论是在 Windows ，还是在 Linux  或者 Mac OS 上，都可以使⽤相同的命令进⾏操作。</p>
<p> Maven 使⽤标准的⽬录结构和默认构建⽣命周期，因此开发者⼏乎不⽤花费多少时间就能够⾃动完成项⽬的基础 构建⼯作。</p>
<p>Maven 能够帮助开发者完成以下任务： </p>
<ul>
<li><p>构建项⽬ </p>
</li>
<li><p>⽣成⽂档 </p>
</li>
<li><p>创建报告 </p>
</li>
<li><p>维护依赖 </p>
</li>
<li><p>软件配置管理 </p>
</li>
<li><p>发布 </p>
</li>
<li><p>部署</p>
</li>
</ul>
<p>总⽽⾔之，Maven 简化并标准化了项⽬构建过程。它将项⽬的编译，⽣成⽂档，创建报告，发布，部署等任务⽆ 缝衔接，构建成⼀套完整的⽣命周期。 </p>
<h4 id="Maven-的⽬标"><a href="#Maven-的⽬标" class="headerlink" title="Maven 的⽬标"></a>Maven 的⽬标</h4><p>Maven 的主要⽬标是为为开发⼈员提供如下内容： </p>
<ul>
<li><p>⼀个可重复使⽤，可维护且易于理解的项⽬综合模型 </p>
</li>
<li><p>与此模型进⾏交互的⼯具和插件 </p>
</li>
<li><p>约定优于配置 </p>
<p>约定优于配置（Convention Over Configuration）是 Maven 最核⼼的涉及理念之⼀ ，Maven对项⽬的⽬录 结构、测试⽤例命名⽅式等内容都做了规定，凡是使⽤ Maven 管理的项⽬都必须遵守这些规则。 Maven 项⽬构建过程中，会⾃动创建默认项⽬结构，开发⼈员仅需要在相应⽬录结构下放置相应的⽂件即可。</p>
</li>
</ul>
<p>maven的主体框架如下图所示：</p>
<p><img src="/2023/06/20/javaEE%E6%80%BB%E7%BB%93/image-20230617215927814.png" alt="image-20230617215927814"></p>
<h4 id="pom-xml文件的作用"><a href="#pom-xml文件的作用" class="headerlink" title="pom.xml文件的作用"></a>pom.xml文件的作用</h4><p>Maven项目构建和依赖管理的核心文件。</p>
<p>Maven通过pom.xml文件实现依赖管理，开发者只需要在pom.xml⽂件中给出所需依赖的相应信息，maven会⾃动的从仓库进行依赖下载并完成项目构架。</p>
<h4 id="maven仓库"><a href="#maven仓库" class="headerlink" title="maven仓库"></a>maven仓库</h4><ol>
<li><p>本地仓库</p>
<p>就是你⾃⼰电脑上的仓库，每个⼈电脑上都有⼀个仓库，默认位置在 当前⽤户名 .m2\repository</p>
</li>
<li><p>私服仓库</p>
<p>⼀般来说是公司内部搭建的 Maven 私服，处于局域⽹中，访问速度较快，这个仓库中存放的 jar ⼀般就是公司内部⾃⼰开发的 jar</p>
</li>
<li><p>中央仓库</p>
<p>有 Apache 团队来维护，包含了⼤部分的 jar，早期不包含 Oracle 数据库驱动，从 2019 年 8 ⽉开 始，包含了 Oracle 驱动</p>
</li>
</ol>
<h4 id="maven常用命令"><a href="#maven常用命令" class="headerlink" title="maven常用命令"></a>maven常用命令</h4><ol>
<li><strong>mvn clean : 清理,清理target下的目标⽂件</strong> </li>
<li><strong>mvn package : 打包,将源码编译后打包为jar&#x2F;war,到target下</strong>  </li>
<li><strong>mvn compile: 编译源代码</strong> </li>
<li><strong>mvn install: 将软件包安装到本地存储库中，用作本地其他项目的依赖项</strong></li>
<li>mvn clean package : 清理且打包,⼀起运⾏ </li>
<li>mvn clean package -maven.test.skip&#x3D;true : 清理且打包,同时跳过test测试 </li>
<li>mvn clean compile package -maven.test.skip&#x3D;true : 清理编译且打包,同时跳过test测试 </li>
<li>mvn test-compile : 运⾏测试 </li>
<li>mvn depoly: 部署,将生产的目标文件上传到本地仓库和公司仓库 </li>
<li>mvn jetty:run : 调⽤ Jetty 插件的 Run ⽬标在 Jetty Servlet 容器中启动 web 应⽤</li>
</ol>
<h1 id="二-Servlet-和过滤器"><a href="#二-Servlet-和过滤器" class="headerlink" title="二. Servlet 和过滤器"></a>二. Servlet 和过滤器</h1><h2 id="1-Servlet基础"><a href="#1-Servlet基础" class="headerlink" title="1.Servlet基础"></a>1.Servlet基础</h2><h3 id="1-Servlet-是什么"><a href="#1-Servlet-是什么" class="headerlink" title="1.Servlet 是什么"></a>1.Servlet 是什么</h3><p>Servlet（Server Applet）是Java 程序，具有独立于平台和协议 Servlet的简称，称为小服务程序或服务连接器，用Java编写的服务器端的特性，主要功能在于交互式地浏览和生成数据，生成动态Web内容。</p>
<h3 id="2-servlet的主要功能"><a href="#2-servlet的主要功能" class="headerlink" title="2.servlet的主要功能"></a>2.servlet的主要功能</h3><ul>
<li>接收前端⽤户参数</li>
<li>动态⽣成返回内容</li>
</ul>
<p>servlet可以看成是连接用户前端和数据库的桥梁，**&#x3D;&#x3D;用来处理Web请求，需要部署到tomcat上运行&#x3D;&#x3D;**。</p>
<p><img src="/2023/06/20/javaEE%E6%80%BB%E7%BB%93/image-20230617230922631.png" alt="image-20230617230922631"></p>
<h3 id="3-部署运行"><a href="#3-部署运行" class="headerlink" title="3.部署运行"></a>3.部署运行</h3><p>请注意以下几点:</p>
<ul>
<li>Servlet类必须继承HttpServlet基类</li>
<li>Servlet必须映射到一个url地址，否则无法访问</li>
<li>Servlet需要实现一个处理http请求方法，如doGet(), doPost()等。</li>
</ul>
<h3 id="4-代码结构"><a href="#4-代码结构" class="headerlink" title="4.代码结构"></a>4.代码结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/hello&quot;)</span></span><br><span class="line"> publicclass HelloServlet <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req,  HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">         resp.getWriter().println(<span class="string">&quot;Welecome to study servlet!&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>doGet()方法参数：</p>
<ul>
<li>HttpServletRequest 用于封装Http请求报文，获取客户端信息</li>
<li>HttpServletResponse 用于封装Http响应报文，给客户端返回响应</li>
</ul>
<h2 id="2-处理Http请求"><a href="#2-处理Http请求" class="headerlink" title="2.处理Http请求"></a>2.处理Http请求</h2><h3 id="1-servlet映射到-url-地址"><a href="#1-servlet映射到-url-地址" class="headerlink" title="1.servlet映射到 url 地址"></a>1.servlet映射到 url 地址</h3><p><strong>使用<code>@WebServlet(&quot;/hello&quot;)</code>注解指定映射路径。</strong></p>
<p>拓展：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(name = &quot;HelloServlet&quot;, urlPatterns = &quot;/hello&quot;)</span>：</span><br><span class="line"><span class="comment">//指定 Servlet 的名称和 URL 地址模式。</span></span><br><span class="line"><span class="meta">@WebServlet(name = &quot;HelloServlet&quot;, urlPatterns = &#123;&quot;/hello&quot;, &quot;/greeting&quot;&#125;)</span>：</span><br><span class="line"><span class="comment">//指定多个 URL 地址模式。</span></span><br><span class="line"><span class="meta">@WebServlet(name = &quot;HelloServlet&quot;, value = &quot;/hello&quot;, initParams = &#123;@WebInitParam(name = &quot;message&quot;, value = &quot;Hello, world!&quot;)&#125;)</span>：</span><br><span class="line"><span class="comment">//指定初始化参数。</span></span><br></pre></td></tr></table></figure>

<p><u>还可使用web.xml 文件进行映射(仅作了解)</u></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>MyServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.example.MyServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>MyServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/myservlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>web.xml</code> 文件中，使用 <code>&lt;servlet&gt;</code> 元素定义 Servlet，并使用 <code>&lt;servlet-name&gt;</code> 元素指定 Servlet 的名称。</li>
<li>然后，在 <code>&lt;servlet-mapping&gt;</code> 元素中，使用 <code>&lt;servlet-name&gt;</code> 元素指定 Servlet 的名称，并使用 <code>&lt;url-pattern&gt;</code> 元素指定要映射的 URL 地址模式。</li>
<li>在这个示例中，Servlet 类 <code>com.example.MyServlet</code> 被映射到 URL 地址模式 <code>/myservlet</code>。</li>
</ul>
<h3 id="2-获取参数-getParameter"><a href="#2-获取参数-getParameter" class="headerlink" title="2.获取参数-getParameter()"></a>2.获取参数-getParameter()</h3><p>JavaServlet中的HttpServletRequest提供了getParameter()接口用于获取客户端参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getParameter</span><span class="params">(String name)</span>;</span><br></pre></td></tr></table></figure>

<p>该方法的参数name为字符串类型，对应于前端的参数名，<strong>返回结果为String类型</strong>，以字符串形式表示所获取到的参数值。</p>
<p>例如：要获取url <a target="_blank" rel="noopener" href="http://localhost:8089/handle?age=90&name=Liqiang%E4%B8%AD%E7%9A%84age%E5%8F%82%E6%95%B0%EF%BC%8C%E5%88%99%E4%BB%A3%E7%A0%81%E4%B8%BA">http://localhost:8089/handle?age=90&amp;name=Liqiang中的age参数，则代码为</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">ageStr</span>  <span class="operator">=</span> request.getParameter(<span class="string">&quot;age&quot;</span>);  </span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">age</span> <span class="operator">=</span> Integer.parseInt(ageStr); </span><br></pre></td></tr></table></figure>

<p>字符串类型转换为其他类型的参考代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**其中s为String类型*/</span>  </span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> Byte.parseByte(s);  </span><br><span class="line"><span class="type">short</span> <span class="variable">t</span> <span class="operator">=</span> Short.parseShort(s);  </span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Integer.parseInt(s);  </span><br><span class="line"><span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> Long.parseLong(s);  </span><br><span class="line"><span class="type">Float</span> <span class="variable">f</span> <span class="operator">=</span> Float.parseFloat(s);  </span><br><span class="line"><span class="type">Double</span> <span class="variable">d</span> <span class="operator">=</span> Double.parseDouble(s);</span><br></pre></td></tr></table></figure>

<p>注意：当需要获取多选框checkbox值和多个电话号码值的时候，使用了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] hobby =request.getParameterValues(<span class="string">&quot;hobby&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>将用户的多个输入值转换为字符串数组。</p>
<h3 id="3-中文乱码问题"><a href="#3-中文乱码问题" class="headerlink" title="3.中文乱码问题"></a>3.中文乱码问题</h3><p><strong>中文乱码产生的原因</strong>：由于tomcat服务器使用的是西文iso-8859-1的编码方式，而浏览器通常使用中文的GBK或者UTF-8编码进行中文文字的表示，因此在使用Servlet接收中文数据时和输出中文数据时容易产生乱码，解决乱码的方式如下：</p>
<p>解决乱码问题:</p>
<p>（1）接收中文参数：<code>request.setCharacterEncoding(&quot;utf-8&quot;);</code> &#x2F;&#x2F;使用utf-8编码解析字符串</p>
<p>（2）在页面输出中文文字:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置输出编码类型和文档类型  </span></span><br><span class="line">response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);  </span><br><span class="line"></span><br><span class="line">response.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="4-servlet-返回结果"><a href="#4-servlet-返回结果" class="headerlink" title="4.servlet 返回结果"></a>4.servlet 返回结果</h3><p><strong>三种方式</strong></p>
<ol>
<li><p>返回文本</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.getWriter().println(<span class="string">&quot;文本&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>请求转发forward</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">dstUrl</span>  <span class="operator">=</span> <span class="string">&quot;/index.jsp&quot;</span>;<span class="comment">//定义跳转的目标url</span></span><br><span class="line"><span class="type">RequestDispatcher</span> <span class="variable">dispatcher</span> <span class="operator">=</span> request.getRequestDispatcher(dstUrl);<span class="comment">//获取分发器</span></span><br><span class="line"><span class="comment">//实现页面跳转，同时将request，response对象传递到新目标</span></span><br><span class="line">dispatcher.forward(request, response);</span><br></pre></td></tr></table></figure>

<p>也可采用链式调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.getRequestDispatcher(dstUrl).forward(request, response);</span><br></pre></td></tr></table></figure>
</li>
<li><p>重定向redirect</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">dstUrl</span>  <span class="operator">=</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">response.sendRedirect(dstUrl);</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>请求转发和重定向跳转方式的区别如下</strong>：</p>
<ol>
<li>使用方法：请求转发使用的是分发器forward()方法，分发器由request对象获取;重定向使用的是response对象的sendRedirect();</li>
<li>浏览器地址栏：请求转发的浏览器URL地址栏不变；重定向浏览器URL的地址栏改变；</li>
<li>实现：请求转发是服务器行为(request)，重定向是客户端行为(response)；</li>
<li>访问次数：转发是浏览器只做了一次访问请求；重定向是浏览器做了至少两次的访问请求；</li>
<li>数据传递：请求转发允许将对象数据传递到下一个目标资源，而重定新不可以；</li>
<li>资源范围：请求转发只能跳转到服务器内部资源；重定向可以调整到服务器外部</li>
</ol>
<p><strong>工作流程</strong></p>
<p><strong>请求转发forward</strong></p>
<ol>
<li>客户端发送Http请求数据给服务器</li>
<li>服务器接收请求数据并调用第一个Servlet处理逻辑</li>
<li>第一个Servlet处理完数据后调用forward()方法将请求传递给服务器内部的下一个Servlet</li>
<li>第二个servlet处理完数据后将最终处理结果返回给客户端</li>
</ol>
<p><img src="/2023/06/20/javaEE%E6%80%BB%E7%BB%93/image-20230618112943893.png" alt="image-20230618112943893"></p>
<p><strong>重定向redirect</strong></p>
<ol>
<li>客户端发送Http请求数据给服务器</li>
<li>服务器接收请求数据并调用一个Servlet处理逻辑</li>
<li>服务器调用sendRedirect()方法将处理结果放进HTTP响应头中并返回给客户端</li>
<li>客户端收到响应结果后，从HTTP响应头中取得相关信息，再次发送请求数据给服务器。</li>
</ol>
<p><img src="/2023/06/20/javaEE%E6%80%BB%E7%BB%93/image-20230618113257850.png" alt="image-20230618113257850"></p>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *根据用户输入参数设置页面跳转方式,type=r或者type=f</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@WebServlet(&quot;/pagejump&quot;)</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageJumpServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">  	<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest  request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">         <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;type&quot;</span>);</span><br><span class="line">         <span class="keyword">if</span> (type==<span class="literal">null</span> || type.isEmpty())&#123;</span><br><span class="line">             response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">             response.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">             response.getWriter().println(<span class="string">&quot;请输入页面跳转类型！(url?type=r或者f)&quot;</span>);</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="type">String</span> <span class="variable">dstUrl</span> <span class="operator">=</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">         <span class="comment">//重定向实现跳转</span></span><br><span class="line">         <span class="keyword">if</span> (type.equals(<span class="string">&quot;r&quot;</span>))&#123;  </span><br><span class="line">              response.sendRedirect(dstUrl);</span><br><span class="line">         &#125;elseif(type.equals(<span class="string">&quot;f&quot;</span>)) &#123;</span><br><span class="line">             <span class="comment">// 请求转发实现跳转并传递对象</span></span><br><span class="line">             <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span><span class="string">&quot;来自于与Servlet的问候&quot;</span>;</span><br><span class="line">             request.setAttribute(<span class="string">&quot;msg&quot;</span>, msg);</span><br><span class="line">             request.getRequestDispatcher(dstUrl).forward(request, response);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-servlet处理-HTTP-不同类型请求"><a href="#5-servlet处理-HTTP-不同类型请求" class="headerlink" title="5.servlet处理 HTTP 不同类型请求"></a>5.servlet处理 HTTP 不同类型请求</h3><ul>
<li>Servlet的service()方法是请求的入口方法，HttpServlet实现service()方法在这个入口方法中根据不同的Http请求方法（如GET、POST请求）调用不同的方法。</li>
<li>HttpServlet中的Service方法会检验用来发送请求的HTTP方法(通过调用request.getMethod() ),并调用以下方法之一：<code>doGet</code>、<code>doPost</code>、doHead、doPut、doTrace、doOptions、doDelete.</li>
</ul>
<p>对应生命周期的服务周期。</p>
<h2 id="3-Servlet-的生命周期"><a href="#3-Servlet-的生命周期" class="headerlink" title="3.Servlet 的生命周期"></a>3.Servlet 的生命周期</h2><h3 id="1-四个周期"><a href="#1-四个周期" class="headerlink" title="1.四个周期"></a>1.四个周期</h3><p>Servlet的生命分为以下4部分：Servlet实例化–&gt;初始化–&gt;服务–&gt;销毁</p>
<p>（1）实例化。对应于new方法。当Servlet第一次被访问时，Web容器将会加载相应的Servlet到Java虚拟机并执行实例化，此时会生成一个Servlet对象。</p>
<p>（2）初始化，对应于init方法。当Servlet容器创建后，会调用并且仅调用一次init()方法，用于初始化Servlet对象。无论有多少客户机访问Servlet，都不会重复执行init（）。</p>
<p>（3）服务。对应service方法。service()方法是Servlet的核心，<strong>负责响应客户的请求</strong>。每当一个客户请求一个HttpServlet对象，该对象的Service()方法就要调用，而且传递给这个方法一个“请求”（ServletRequest）对象和一个“响应”（ServletResponse）对象作为参数。实际执行中是根据Http请求方法调用相应的do功能。</p>
<p>（4）销毁，对应destroy方法。destroy()方法仅执行一次，只在Web服务器端停止并卸载Servlet时执行。当Servlet对象被销毁时，将释放其占用的资源。</p>
<p><img src="/2023/06/20/javaEE%E6%80%BB%E7%BB%93/image-20230618134041622.png" alt="image-20230618134041622"></p>
<p>Servlet接口类中提供了Servlet生命周期中3个方法的定义，相关功能说明如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Servlet</span> &#123;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException;      </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req,  ServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException;      </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在HttpServlet类中提供了service方法的具体实现，service()方法主要根据Http请求方法的不同调用不同的do方法进行处理。</p>
<p>注意几点：</p>
<p>（1）一个Servlet对象只有在第一次访问时被创建，之后将常驻内存，并使用该对象处理后的用户请求；<strong>inti()方法</strong></p>
<p>（2）一个Servlet对象在处理不同的客户端请求时，往往使用多线程执行，即针对每一个客户端请求开启一个线程；</p>
<p>（3）Servlet只有在web容器重启或者停止时候才会被销毁。<strong>destroy()方法</strong></p>
<h3 id="2-Servlet处理请求的过程"><a href="#2-Servlet处理请求的过程" class="headerlink" title="2.Servlet处理请求的过程"></a>2.Servlet处理请求的过程</h3><p>（1）客户端发送请求给服务器。</p>
<p>（2）容器根据请求及web.xml判断对应的Servlet是否存在，如果不存在则返回404。</p>
<p>（3）容器根据请求及web.xml判断对应的Servlet是否已经被实例化，若是相应的Servlet没有被实例化，则容器将会加载相应的Servlet到Java虚拟机并实例化。</p>
<p>（4）调用实例对象的service()方法，并开启一个新的线程去执行相关处理。调用servce方法，判断是调用doGet方法还是doPost方法。</p>
<p>（5）业务完成后响应相关的页面发送给客户端。</p>
<h2 id="4-过滤器FIlter"><a href="#4-过滤器FIlter" class="headerlink" title="4.过滤器FIlter"></a>4.过滤器FIlter</h2><h3 id="1-过滤器用途和工作原理"><a href="#1-过滤器用途和工作原理" class="headerlink" title="1.过滤器用途和工作原理"></a>1.过滤器用途和工作原理</h3><p><strong>用途：</strong></p>
<p>过滤器是一种Web组件，用于对客户端发送的请求信息和服务器返回的响应结果进行处理。<strong>即可以拦截请求和应答</strong></p>
<p><strong>工作原理：</strong></p>
<ul>
<li>通过使用过滤器，可以拦截客户端的请求和响应，查看、提取或者以某种方式操作正在客户端和服务器之间进行交换的数据。</li>
<li>通过使用过滤器，可以对Web组件的前期处理和后期处理进行控制。</li>
<li>过滤器可以有多个，以构成一个<strong>过滤器链</strong>。Servlet容器会根据过滤器的配置情况来决定过滤器的调用次序。</li>
</ul>
<p>过滤器使用的设计模式为责任链设计模式</p>
<p><img src="/2023/06/20/javaEE%E6%80%BB%E7%BB%93/image-20230618141212966.png" alt="image-20230618141212966"></p>
<h3 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2.应用场景"></a>2.应用场景</h3><ul>
<li>EncodingFilter 字符编码过滤器 <a href="#%E7%BC%96%E7%A0%81%E8%BF%87%E6%BB%A4%E5%99%A8">点击查看示例</a><br>用于设置 HTTP 请求字符编码的过滤器，通过过滤器参数encoding指明使用何种字符编码，用于处理Html Form请求参数的中文问题。</li>
<li>AuthorityFilter 权限过滤器<a href="#%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E8%BF%87%E6%BB%A4%E5%99%A8">点击查看示例</a><br>在一个系统中通常有多个权限的用户。不同权限用户的可以浏览不同的页面。使用Filter进行判断不仅省下了代码量，而且如果要更改的话只需要在Filter文件里动下就可以。</li>
</ul>
<h3 id="3-过滤器的部署"><a href="#3-过滤器的部署" class="headerlink" title="3.过滤器的部署"></a>3.过滤器的部署</h3><p>1.定义的过滤器类必须要实现接口javax.servlet.Filter，并且实现该接口中定义的3个方法：</p>
<ul>
<li>vod init(…)：用于初始化过滤器。</li>
<li>void destroy()：用于销毁过滤器。</li>
<li>void doFilter(…)：用于执行过滤操作。</li>
</ul>
<p>2.在web.xml配置文件中部署Filter<br>用<filter>元素定义过滤器，<filter>元素有两个必要子元素：</p>
<ul>
<li><filter-name>用来设定过滤器的名字</li>
<li><filter-class >用来设定过滤器的类路径</li>
</ul>
<p>用<filter-mapping>配置过滤器的映射信息，有两个必要的子元素：</p>
<ul>
<li><filter-name>用来设定过滤器的名字</li>
<li><url-pattern>用来设定被过滤的组件</li>
</ul>
<p>3.用@WebFilter(“&#x2F;*”)部署</p>
<p>若用注解部署过滤器链则会随机调用过滤器，即无顺序</p>
<p>示例：</p>
<h4 id="编码过滤器"><a href="#编码过滤器" class="headerlink" title="编码过滤器"></a><strong>编码过滤器</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EncodingFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig config)</span> <span class="keyword">throws</span> ServletException &#123;    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse resp, FilterChain chain)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (HttpServletRequest)req;</span><br><span class="line">        <span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> (HttpServletResponse)resp;</span><br><span class="line"></span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        chain.doFilter(req, resp);<span class="comment">//调用下一个过滤器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>EncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>jee.demo.servlet.filter.EncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>EncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="用户权限过滤器"><a href="#用户权限过滤器" class="headerlink" title="用户权限过滤器"></a><strong>用户权限过滤器</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthenFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig config)</span> <span class="keyword">throws</span> ServletException &#123;    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse resp, FilterChain chain)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (HttpServletRequest)req;</span><br><span class="line">        <span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span>(HttpServletResponse)resp;</span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        <span class="keyword">if</span>(session.getAttribute(<span class="string">&quot;LoginUser&quot;</span>)== <span class="literal">null</span>)&#123;</span><br><span class="line">            response.sendRedirect(request.getContextPath()+<span class="string">&quot;/login.jsp&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        chain.doFilter(req, resp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>AuthenFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>jee.demo.servlet.filter.AuthenFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>AuthenFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/test/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-过滤器链"><a href="#4-过滤器链" class="headerlink" title="4.过滤器链"></a>4.过滤器链</h3><p><strong>过滤器链的顺序是根据web.xml配置文件中<filter-mapping>元素的顺序决定的</strong>，若用注解部署过滤器链则会随机调用过滤器，即无顺序</p>
<h1 id="三-Spring-IOC-和单例设计模式"><a href="#三-Spring-IOC-和单例设计模式" class="headerlink" title="三. Spring IOC 和单例设计模式"></a>三. Spring IOC 和单例设计模式</h1><h2 id="1-Spring-的核心IOC-和-AOP"><a href="#1-Spring-的核心IOC-和-AOP" class="headerlink" title="1.Spring 的核心IOC 和 AOP"></a>1.Spring 的核心IOC 和 AOP</h2><p><strong>IoC（Inverse of Control 控制反转）</strong></p>
<p>控制反转:<strong>对象的创建交给外部容器完成</strong>。不直接在代码中创建对象。</p>
<p>IOC 容器的作用</p>
<ul>
<li>依赖处理，通过依赖查找或者依赖注入</li>
<li>管理托管的资源（Java Bean 或其他资源）的生命周期</li>
<li>管理配置（容器配置、外部化配置、托管的资源的配置）</li>
</ul>
<p><strong>控制反转解决对象的管理（创建、销毁等）问题。</strong></p>
<p>依赖注入（dependency injection）:<strong>实现对象之间的依赖关系。</strong>在创建完对象之后，对象之间的关系处理就是依赖注入。</p>
<p>Spring提供了IOC容器。无论创建对象、处理对象之间的依赖关系、对象创建的时间还是数量，都在Spring IOC容器配置完成。</p>
<p>IOC核心思想：资源不由资源的使用方管理，而由不使用资源的第三方管理。</p>
<p>好处（为什么要控制反转）：<br>（1）资源集中管理，实现资源的可配置和易管理；<br>（2）降低使用资源双方的依赖程度。</p>
<p><strong>AOP（Aspect Oriented Programming 面向切面编程）</strong></p>
<p>通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个 热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑 的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p>
<h2 id="2-IOC-容器中对象的注入和装配"><a href="#2-IOC-容器中对象的注入和装配" class="headerlink" title="2.IOC 容器中对象的注入和装配"></a>2.IOC 容器中对象的注入和装配</h2><p>spring 默认采用单例模式对管理 Bean 对象</p>
<h3 id="基于-xml"><a href="#基于-xml" class="headerlink" title="基于 xml"></a>基于 xml</h3><p>基于 XML 的 Bean 装配是最基本的 Bean 装配方式之一。 在基于 XML 的 Spring 配置中声明一个 bean，使用 spring-beans 模式元素，参考如下：<code>&lt;bean id=&quot;..&quot; class=&quot;…&quot; /&gt;</code></p>
<p>Bean实体类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span>&#123;</span><br><span class="line">    Long id;</span><br><span class="line">    Double price;</span><br><span class="line">    String color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>spring-config.xml文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;BYD&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.javaee.entity.Car&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">vlaue</span>=<span class="string">&quot;202101&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;price&quot;</span> <span class="attr">vlaue</span>=<span class="string">&quot;220&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;color&quot;</span> <span class="attr">vlaue</span>=<span class="string">&quot;蓝色&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    ClassPathXmlApplicationContext beanFactory=<span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;spring-config.xml&quot;</span>);<span class="comment">//xml配置文件</span></span><br><span class="line">	Car byd=(Car)beanFactory.getBean(<span class="string">&quot;BYD&quot;</span>);<span class="comment">//beanId </span></span><br><span class="line">    sout(byd);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="基于注解"><a href="#基于注解" class="headerlink" title="基于注解"></a>基于注解</h3><p>基于注解的自动化 Bean 装配是最常用 Bean 装配方式之一。需要我们对 Spring 的常用注解有个基本认识。spring 注解可以减少 xml 配置；利用 Java 的反射机制获取类结构信息，有效减少配置的工作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CompactDisc</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span><span class="comment">//Spring 会自动扫描，生成该 Java 类对应的 Bean 实例。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NovChopinCD</span> <span class="keyword">implements</span> <span class="title class_">CompactDisc</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String title=<span class="string">&quot;名称：十一月的萧邦&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> String artist=<span class="string">&quot;周杰伦&quot;</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;播放专辑&quot;</span>+title+<span class="string">&quot;by&quot;</span>+artist);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CdPlayer</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CompactDisc cd;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">playCd</span><span class="params">()</span>&#123;</span><br><span class="line">        cd.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>spring-config.xml 文件配置,指定类所在包</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.javaee&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJavaCfg</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        BeanFactory bf=<span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;spring-config.xml&quot;</span>);</span><br><span class="line">        CdPlayer cdPlayer=(CdPlayer) bf.getBean(<span class="string">&quot;cdPlayer&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;演示Spring的自动扫描装配&quot;</span>);</span><br><span class="line">        cdPlayer.playCd();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">演示Spring的自动扫描装配</span><br><span class="line">播放专辑名称：十一月的萧邦by周杰伦</span><br></pre></td></tr></table></figure>

<p><strong>注解总结</strong></p>
<p><strong>@Component</strong>：代表 Spring IoC 会把该java类扫描生成 Bean 实例，位于 Java 类声明之前。对象 id 为类名第一个字母小写，即 CdPlayer 对应的 Bean id 为 cdPlayer。</p>
<p><strong>@Autowired</strong>：实现属性自动装配,Spring 会根据类型去寻找定义的 Bean 然后进行byType注入，如果需要 byName（byName 就是通 过 id 去标识）注入，增加@Qualifier 注释。例如上文中需要注入的是NovChopinCD类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;novChopinCD&quot;)</span></span><br><span class="line"><span class="keyword">private</span> CompactDisc cd;</span><br></pre></td></tr></table></figure>

<h3 id="基于-Java-配置类"><a href="#基于-Java-配置类" class="headerlink" title="基于 Java 配置类"></a>基于 Java 配置类</h3><p>通过 java 配置类配置 Bean 的优点：</p>
<p>（1）更加强大：自动装配实现的功能，它都能实现，还能实现自动装配不能实现的功能。</p>
<p>（2）容易理解：通过 java 代码原生态的方式来配置 Bean，代 码读起来也比较容易理解。</p>
<p>（3）类型安全并且对重构友好</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is MyBean&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.javaee.anntation&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyBean <span class="title function_">myBean</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyBean</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ApplicationContext context=<span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(JavaConfig.class);</span><br><span class="line">        MyBean myBean=(MyBean) context.getBean(<span class="string">&quot;myBean&quot;</span>);</span><br><span class="line">        myBean.say();</span><br><span class="line"></span><br><span class="line">        CdPlayer cdPlayer=(CdPlayer) context.getBean(<span class="string">&quot;cdPlayer&quot;</span>);</span><br><span class="line">        cdPlayer.playCd();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This is MyBean</span><br><span class="line">播放专辑名称：十一月的萧邦by周杰伦</span><br></pre></td></tr></table></figure>

<p>注解总结</p>
<p><strong>@Configuration</strong>：表示该类是一个配置类并用于构建 bean 定义，初始化 Spring 容器，被注解类包含有一个或多个被@Bean 注解的方法，这些方法将会被 AnnotationConfigApplicationContext 或 AnnotationConfigWebApplicationContext 类进行扫描</p>
<p><strong>@ComponentScan</strong>：扫描定义的包,如@ComponentScan( basePackages &#x3D; “jee.java.config” )</p>
<p><strong>@Bean</strong>：表明该类交由Spring管理，若未指定名称，默认采用的是“方法名”+“首字母小写”的配置方式，即方法mybean的id为mybean。</p>
<h2 id="3-单例设计模式"><a href="#3-单例设计模式" class="headerlink" title="3.单例设计模式"></a>3.单例设计模式</h2><p><strong>定义</strong>：</p>
<p>只需要三步就可以保证对象的唯一性<br>(1) 不允许其他程序用new对象,即<strong>私有化该类的构造函数</strong><br>(2) 在该类中创建对象<br>(3) 对外提供一个可以让其他程序获取该对象的方法</p>
<p><strong>优点</strong></p>
<p>单例模式主要是为了避免因为创建了多个实例造成资源的浪费，且多个实例由于多次调用容易导致结果结果出现错误，而使用单例模式能够保证整个应用中有且只有一个实例。</p>
<p><strong>懒汉式</strong>,没有考虑线程安全，比饿汉更节省资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance=<span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance==<span class="literal">null</span>)&#123;</span><br><span class="line">			instance=<span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	 	<span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>饿汉式</strong>,没有懒加载，可能会造成内存的浪费</p>
<p>实现比较简单，在类加载的时候就完成了实例化，避免了线程的同步问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四-SpringBoot-核心配置"><a href="#四-SpringBoot-核心配置" class="headerlink" title="四. SpringBoot 核心配置"></a>四. SpringBoot 核心配置</h1><h2 id="1-SpringBoot-框架的特点"><a href="#1-SpringBoot-框架的特点" class="headerlink" title="1.SpringBoot 框架的特点"></a>1.SpringBoot 框架的特点</h2><p>•可快速构建独立的Spring应用 </p>
<p>•直接嵌入Tomcat、Jetty和Undertow服务器（无需部署WAR文件）</p>
<p>•提供依赖启动器简化构建配置</p>
<p>•极大程度的自动化配置Spring和第三方库</p>
<p>•提供生产就绪功能</p>
<p>•极少的代码生成和XML配置</p>
<p>•约定大于配置</p>
<h2 id="2-springboot-项目的代码结构"><a href="#2-springboot-项目的代码结构" class="headerlink" title="2.springboot 项目的代码结构"></a>2.springboot 项目的代码结构</h2><p><img src="/2023/06/20/javaEE%E6%80%BB%E7%BB%93/image-20230619014641653.png" alt="image-20230619014641653"></p>
<h2 id="3-SpringBoot-的配置文件"><a href="#3-SpringBoot-的配置文件" class="headerlink" title="3.SpringBoot 的配置文件"></a>3.SpringBoot 的配置文件</h2><h3 id="application-properties"><a href="#application-properties" class="headerlink" title="application.properties"></a><strong>application.properties</strong></h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.address</span>=<span class="string">80</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8443</span></span><br><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">spring.config.additional-location</span>= <span class="string"></span></span><br><span class="line"><span class="attr">spring.config.location</span>= <span class="string"></span></span><br><span class="line"><span class="attr">spring.config.name</span>=<span class="string">application</span></span><br></pre></td></tr></table></figure>

<h3 id="application-yaml"><a href="#application-yaml" class="headerlink" title="application.yaml"></a><strong>application.yaml</strong></h3><p>•YAML文件格式是Spring Boot支持的一种JSON超集文件格式。</p>
<p>•相较于传统的Properties配置文件，YAML文件以数据为核心，是一种更为直观且容易被电脑识别的数据序列化格式。</p>
<p>•application.yaml文件的工作原理和application.properties一样。</p>
<p><strong>语法格式</strong>：key:（空格）value  缩进 2 个空格</p>
<ol>
<li>value的值为普通数据类型</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">/hello</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>value的值为数组和单列集合</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//缩进式写法</span></span><br><span class="line"><span class="attr">person:</span></span><br><span class="line">  <span class="attr">hobby:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">play</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">read</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">sleep</span> </span><br><span class="line"><span class="string">//行内式写法</span></span><br><span class="line"><span class="attr">person:</span></span><br><span class="line">  <span class="attr">hobby:</span> [<span class="string">play</span>,<span class="string">read</span>,<span class="string">sleep</span>]</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>value的值为Map集合或对象</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//缩进式写法</span></span><br><span class="line"><span class="attr">person:</span></span><br><span class="line">  <span class="attr">map:</span></span><br><span class="line">    <span class="attr">k1:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">k2:</span> <span class="string">v2</span></span><br><span class="line"><span class="string">//行内式写法</span></span><br><span class="line"><span class="attr">person:</span></span><br><span class="line">    <span class="attr">map:</span> &#123;<span class="attr">k1:</span> <span class="string">v1</span>,<span class="attr">k2:</span> <span class="string">v2</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-配置文件的属性值的注入"><a href="#4-配置文件的属性值的注入" class="headerlink" title="4.配置文件的属性值的注入"></a>4.配置文件的属性值的注入</h2><h3 id="ConfigurationProperties-注入到整个类"><a href="#ConfigurationProperties-注入到整个类" class="headerlink" title="@ConfigurationProperties(注入到整个类)"></a><strong>@ConfigurationProperties(注入到整个类)</strong></h3><p>使用@ConfigurationProperties注解批量注入属性值时，要保证配置文件中的属性与对应实体类的属性一致，否则无法正确获取并注入属性值。</p>
<p>@ConfigurationProperties其实可以看成多个@Value注入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;person&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id; </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>application.yaml</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">person:</span></span><br><span class="line">  <span class="attr">id:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">xzx</span></span><br></pre></td></tr></table></figure>

<h3 id="Value-单个值的注入"><a href="#Value-单个值的注入" class="headerlink" title="@Value()单个值的注入"></a>@Value()单个值的注入</h3><p>语法：@Value(“${key}”)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	<span class="meta">@Value(&quot;$&#123;person.id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;  </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>两种注解的对比分析</strong></p>
<p><img src="/2023/06/20/javaEE%E6%80%BB%E7%BB%93/image-20230619023706905.png" alt="image-20230619023706905"></p>
<p>关键：@ConfigurationProperties需要有set()，@Value无需set方法。</p>
<h1 id="五-SpringBoot-Web-层"><a href="#五-SpringBoot-Web-层" class="headerlink" title="五. SpringBoot Web 层"></a>五. SpringBoot Web 层</h1><h2 id="1-映射到-URL"><a href="#1-映射到-URL" class="headerlink" title="1.映射到 URL"></a>1.映射到 URL</h2><p>@RequestMapping是SpringBoot提供的⼀个地址映射的基础注解，主要⽤途是将Web请求与请求处理类中的⽅法 进⾏映射。 </p>
<p>@RequestMapping注解拥有以下的六个配置属性： </p>
<ul>
<li>value :映射的请求URL或者其别名 </li>
<li>method :兼容HTTP的⽅法名 </li>
<li>params :根据HTTP参数的存在、缺省或值对请求进⾏过滤 </li>
<li>header :根据HTTP Header的存在、缺省或值对请求进⾏过滤 </li>
<li>consume :设定在HTTP请求正⽂中允许使⽤的媒体类型 </li>
<li>product :在HTTP响应体中允许使⽤的媒体类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoController</span>&#123;</span><br><span class="line"> <span class="meta">@RequestMapping(value = &quot;/demo/home&quot;, method = RequestMethod.GET)</span></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">home</span><span class="params">()</span>&#123;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="string">&quot;home&quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以采⽤分层的形式表示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/demo&quot;）</span></span><br><span class="line"><span class="meta">public class DemoController&#123;</span></span><br><span class="line"><span class="meta"> @RequestMapping(value = &quot;/home&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="meta"> public String home()&#123;</span></span><br><span class="line"><span class="meta"> 	return &quot;home&quot;;</span></span><br><span class="line"><span class="meta"> &#125;</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure>

<p>映射到多个URL地址</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value = &#123;&quot;path1&quot;, &quot;path2&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">multiUrl</span><span class="params">()</span> &#123;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="string">&quot;演示映射到多个不同的url地址&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Spring5之后，出现了更简单的Http 请求⽅法映射的注解，分别是：</p>
<p>@GetMapping ⽤于处理HTTP GET请求 </p>
<p>@PostMapping ⽤于处理HTTP POST请求 </p>
<p>@PutMapping ⽤于处理HTTP PUT请求 </p>
<p>@DeleteMapping ⽤于处理HTTP DELETE请求 </p>
<p>@PatchMapping ⽤于处理HTTP PATCH请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="comment">/*指定url地址*/</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;api&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpMappingController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/method&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handleGetMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="string">&quot;处理Http GET请求&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意在类前还需@RequestMapping(“api”)。</p>
<h2 id="2-返回结果"><a href="#2-返回结果" class="headerlink" title="2.返回结果"></a>2.返回结果</h2><p>返回结果类型通常包括：返回HTML页面，返回JSON文本数据。</p>
<p>在控制器类上标注@Controller 注解，则方法默认返回页面视图，即HTML页面。</p>
<p>在方法上如果使用@ResponseBody 注解，则直接将返回值序列化json。</p>
<p>使用Model可以将数据传递到视图页面，下面两种写法功能相同。ModelAndView同时包含了视图和模型对象。</p>
<p><img src="/2023/06/20/javaEE%E6%80%BB%E7%BB%93/image-20230619143343932.png" alt="image-20230619143343932"></p>
<p>在控制器类上标注@RestController，则所有方法都返回JSON数据。可以在方法返回Map对象，该</p>
<p>对象会自动被转换为JSON数据格式。</p>
<h2 id="3-控制器和Servlet的区别"><a href="#3-控制器和Servlet的区别" class="headerlink" title="3.控制器和Servlet的区别"></a>3.控制器和Servlet的区别</h2><p>•1.一个Servlet类只能处理一个HTTP请求，需要通过action等参数进行类别区分；</p>
<p>•2. Servlet获取前端数据比较低级，需要手动进行转换；</p>
<p>•3.后端数据校验需要手动完成；</p>
<p>•4.使用response输出响应比较繁琐；</p>
<p>•5.页面跳转代码复杂；</p>
<h2 id="4-Controller和-RestController的区别"><a href="#4-Controller和-RestController的区别" class="headerlink" title="4.@Controller和@RestController的区别"></a>4.@Controller和@RestController的区别</h2><p>@RestController &#x3D; @Controller + @ResonseBody</p>
<p>使用**@Controller<strong>注解作用于类声明时，当方法返回值为String类型，默认表示返</strong>回该字符串对应的页面视图**，该页面后缀为.html，位于resourses&#x2F;templates目录下。在方法前面使用@ResponseBody表示返回文本数据。</p>
<p>使用**@RestController<strong>注解作用于类声明时，表示该类所有的方法均</strong>返回文本数据**，而非返回视图页面名称。</p>
<p>@Controller返回页面视图名称时，需要添加Thymeleaf依赖放起到效果。</p>
<h2 id="5-前端参数的获取"><a href="#5-前端参数的获取" class="headerlink" title="5.前端参数的获取"></a>5.<strong>前端参数的获取</strong></h2><h3 id="获取单个参数-RequestParam"><a href="#获取单个参数-RequestParam" class="headerlink" title="获取单个参数--@RequestParam"></a>获取单个参数--@RequestParam</h3><p>&#x2F;test&#x2F;hello?a&#x3D;123    key&#x3D;value 类型 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(“hello”)</span> </span><br><span class="line">Public String <span class="title function_">toHello</span><span class="params">(<span class="meta">@RequestParam</span> <span class="type">int</span> a )</span>&#123; </span><br><span class="line">	<span class="keyword">return</span> “hello”; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述过程没有显式指定@RequestParam的value或name属性，因此形参名必须与请求参数名⼀⼀对应。如果我 们显式指定了value或name属性，那么形参名就可以任意了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(“hello”)</span> </span><br><span class="line">Public String <span class="title function_">toHello</span><span class="params">(<span class="meta">@RequestParam(&quot;a&quot;)</span> <span class="type">int</span> age )</span>&#123; </span><br><span class="line">	<span class="keyword">return</span> “hello”; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>@RequestParam标注在⽅法形参上，⽤来获取HTTP请求参数值。 </li>
<li>如果形参为基本类型，可以获取对应的请求参数值。此时需要注意请求参数名是否需要与形参名⼀致（是否 指定value或name属性）。 </li>
<li>如果形参为Map或MultiValueMap，则可以⼀次性获取全部请求参 数。此时请求参数名与形参名⽆关。</li>
<li>required属性默认为true，此时必须保证HTTP请求中包含与形参⼀致的请求参数，否则会报错。 </li>
<li>我们可以使⽤defaultValue属性指定默认值，此时required⾃动指定成false，表示如果没有提供该请 求参数，则会使⽤该值。</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(“hello”)</span> </span><br><span class="line">Public String <span class="title function_">toHello</span><span class="params">(<span class="meta">@RequestParam(required = false, defaultValue = &quot;1000&quot;)</span> <span class="type">int</span> a )</span>&#123; </span><br><span class="line">	<span class="keyword">return</span> “hello”; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取路径参数-PathVariable"><a href="#获取路径参数-PathVariable" class="headerlink" title="获取路径参数--@PathVariable"></a>获取路径参数--@PathVariable</h3><p>路径变量&#x2F;test&#x2F;hello&#x2F;123</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(“hello/&#123;a&#125;”)</span></span><br><span class="line">Public String <span class="title function_">toHello</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> a )</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> “hello”;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取JSON格式的参数值-RequestBody"><a href="#获取JSON格式的参数值-RequestBody" class="headerlink" title="获取JSON格式的参数值--@RequestBody"></a>获取JSON格式的参数值--@RequestBody</h3><p>@RequestBody标注在⽅法形参上，⽤来接收HTTP请求体中的json数据。</p>
<p>注意：由于Json数据只能通过POST请求进⾏传递(数据存放在Http Body中)，因此@RequestBody需要 和@PostMapping配置使⽤，此时不能使⽤GET请求。此时Content-Type对应的值为 application&#x2F;json。</p>
<p>Spring会使⽤HttpMessageConverter对象⾃动将对应的数据解析成指定的Java对象。例如，我们发送如下 HTTP请求：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST http://localhost:8080/student</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;Xianhuii&quot;,</span><br><span class="line">  &quot;age&quot;: 18</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;student&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Student <span class="title function_">getJsonData</span><span class="params">(<span class="meta">@RequestBody</span>  Student student)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Student内容:&quot;</span>+ student);</span><br><span class="line">    <span class="keyword">return</span> student;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⼀般来说在Controller⽅法中仅可声明⼀个@RequestBody注解的参数，将请求体中的所有数据转换成对应的 POJO对象。</p>
<h2 id="6-发送响应数据"><a href="#6-发送响应数据" class="headerlink" title="6.发送响应数据"></a>6.发送响应数据</h2><h3 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h3><p>@ResponseBody可以标注在类或⽅法上，它的作⽤是将⽅法返回值作为HTTP响应体发回给客户端， 与@ResquestBody刚好相反。 我们可以将它标注到⽅法上，表示仅有handle()⽅法的返回值会被直接绑定到响应体中，注意到此时类标注成@Controller：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentController</span> &#123;</span><br><span class="line"> </span><br><span class="line">     <span class="meta">@ResponseBody</span></span><br><span class="line">     <span class="meta">@GetMapping(&quot;/student&quot;)</span></span><br><span class="line">     <span class="keyword">public</span> Student <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Xianhuii&quot;</span>, <span class="number">18</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以将它标注到类上，表示类中所有⽅法的返回值都会被直接绑定到响应体中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/student&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Xianhuii&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，@ResponseBody和@Controller相结合，就变成了@RestController注解，也是前后端分离中最常⽤的 注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/student&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Xianhuii&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果客户端发送如下HTTP请求：GET <a target="_blank" rel="noopener" href="http://localhost:8080/student%E3%80%82%E6%AD%A4%E6%97%B6%E4%B8%8A%E8%BF%B0%E4%BB%A3%E7%A0%81%E9%83%BD%E4%BC%9A%E6%9C%89%E7%9B%B8%E5%90%8C%E7%9A%84HTTP%E5%93%8D">http://localhost:8080/student。此时上述代码都会有相同的HTTP响</a> 应，表示接收到student的json数据：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> </span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line"><span class="attribute">Transfer-Encoding</span><span class="punctuation">: </span>chunked</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Tue, 04 May 2021 13:04:15 GMT</span><br><span class="line"><span class="attribute">Keep-Alive</span><span class="punctuation">: </span>timeout=60</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"></span><br><span class="line"><span class="language-json"><span class="punctuation">&#123;</span></span></span><br><span class="line"><span class="language-json">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Xianhuii&quot;</span><span class="punctuation">,</span></span></span><br><span class="line"><span class="language-json">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">18</span></span></span><br><span class="line"><span class="language-json"><span class="punctuation">&#125;</span></span></span><br></pre></td></tr></table></figure>

<p>总结@ResponseBody的⽤法：</p>
<ul>
<li>@ResponseBody表示将⽅法返回值直接绑定到web响应体中。 </li>
<li>@ResponseBody可以标注到类或⽅法上。类上表示内部所有⽅法的返回值都直接绑定到响应体中，⽅法上表 示仅有该⽅法的返回值直接绑定到响应体中。 </li>
<li>@ResponseBody标注到类上时，与@Controller相结合可以简写成@RestController，这也是通常使⽤的注解。 我们可以灵活地构造合适的返回对象，结合@ResponseBody，⽤作与实际项⽬最匹配的响应体返回。</li>
</ul>
<h2 id="7-数据校验"><a href="#7-数据校验" class="headerlink" title="7.数据校验"></a>7.数据校验</h2><h3 id="Valid-POJO类校验"><a href="#Valid-POJO类校验" class="headerlink" title="@Valid-POJO类校验"></a>@Valid-POJO类校验</h3><p>实现方法：</p>
<p>（1）在POJO类的属性添加对应的校验注解。</p>
<p>（2）在控制器方法中使用@Valid注解表示对参数进行校验，同时后面使用Errors&#x2F;BindingResult来捕获错误信息，并进行处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="meta">@NotNull</span>   </span><br><span class="line">    <span class="meta">@Size(min = 2, message = &quot;姓名长度不能小于2个字符&quot;)</span>    </span><br><span class="line">    String name;</span><br><span class="line">    <span class="meta">@NotNull</span>   </span><br><span class="line">    <span class="meta">@Length(min = 6, max = 6, message = &quot;学号长度为6位&quot;)</span>    </span><br><span class="line">    String studentNo;   </span><br><span class="line">    <span class="meta">@Min(value = 10, message = &quot;年龄不能小于10岁&quot;)</span></span><br><span class="line">    Integer age;    </span><br><span class="line">    <span class="meta">@Email(message = &quot;Email地址格式不符合规范&quot;)</span>    </span><br><span class="line">    String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/06/20/javaEE%E6%80%BB%E7%BB%93/image-20230619144302671.png" alt="image-20230619144302671"></p>
<h3 id="Validated-方法参数合法性校验"><a href="#Validated-方法参数合法性校验" class="headerlink" title="@Validated-方法参数合法性校验"></a>@Validated-方法参数合法性校验</h3><p>实现方法：</p>
<ol>
<li>在控制器类标注@Validated 注解。</li>
<li>在方法中可以使用JSR303提供的注解来完成校验，例如@NotNull等。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;validate&quot;)</span> </span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValidateController</span> &#123;    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;param&quot;)</span>    </span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">	<span class="keyword">public</span>  String <span class="title function_">validateParam</span><span class="params">( <span class="meta">@RequestParam</span> <span class="meta">@Min(value = 100,message = &quot;不能小于100&quot;)</span> Integer value)</span>&#123;        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;输入正确,数值为:&quot;</span>+ value;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Valid和-Validated的区别"><a href="#Valid和-Validated的区别" class="headerlink" title="@Valid和@Validated的区别"></a>@Valid和@Validated的区别</h3><p>@Valid是使用Hibernate validation的时候使用</p>
<p>@Validated是只用Spring Validator校验机制使用</p>
<blockquote>
<p>说明：java的JSR303声明了@Valid这类接口，而Hibernate-validator对其进行了实现。</p>
</blockquote>
<p><strong>注解位置：</strong></p>
<p>@Validated：用在类型、方法和方法参数上。但不能用于成员属性（field）</p>
<p>@Valid：可以用在方法、构造函数、方法参数和成员属性（field）上</p>
<h1 id="六-Mybatis-–-ORM"><a href="#六-Mybatis-–-ORM" class="headerlink" title="六. Mybatis – ORM"></a>六. Mybatis – ORM</h1><p>持久化是程序数据在瞬时状态和持久状态间转换的过程</p>
<h2 id="1-ORM（Object-Relational-Mapping）"><a href="#1-ORM（Object-Relational-Mapping）" class="headerlink" title="1.ORM（Object Relational Mapping）"></a>1.ORM（Object Relational Mapping）</h2><p>编写程序的时候，以面向对象的方式处理数据</p>
<p>保存数据的时候，却以关系型数据库的方式存储</p>
<p><strong>ORM就是一种为了解决面向对象与关系型数据库中数据类型不匹配的技术，它通过描述Java对象与数据库表之间的映射关系，自动将Java应用程序中的对象持久化到关系型数据库的表中。</strong></p>
<p><strong>ORM解决方案包含下面四个部分</strong></p>
<ul>
<li>在持久化对象上执行基本的增、删、改、查操作</li>
<li>对持久化对象提供一种查询语言或者API</li>
<li>对象关系映射工具</li>
<li>提供与事务对象交互、执行检查、延迟加载以及其他优化功能</li>
</ul>
<h2 id="2-Mybatis和ORM"><a href="#2-Mybatis和ORM" class="headerlink" title="2.Mybatis和ORM"></a>2.Mybatis和ORM</h2><p>MyBatis是一个数据持久层(ORM)框架。把实体类和SQL语句之间建立了映射关系，是一种半自动化的ORM实现</p>
<p><strong>MyBatis的工作原理</strong></p>
<p><img src="/2023/06/20/javaEE%E6%80%BB%E7%BB%93/image-20230619150634196.png" alt="image-20230619150634196"></p>
<h2 id="3-MySQL数据查询分页查询SQL"><a href="#3-MySQL数据查询分页查询SQL" class="headerlink" title="3.MySQL数据查询分页查询SQL"></a>3.MySQL数据查询分页查询SQL</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 limit <span class="keyword">start</span>,count</span><br></pre></td></tr></table></figure>

<h3 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h3><p><strong>说明:</strong></p>
<ol>
<li>limit是分页查询关键字</li>
<li>start表示开始行索引，默认是0</li>
<li>count表示查询条数</li>
</ol>
<p>limit0,10 表示从0开始查询十条数据</p>
<p><strong>n:求第几页的数据</strong><br><strong>m:每页显示m条数据</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">公式:</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tablename limit (n<span class="number">-1</span>)<span class="operator">*</span>m,m;</span><br><span class="line"></span><br><span class="line">例子:</span><br><span class="line">第一页数据,一页显示<span class="number">3</span>行数据</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tablename limit <span class="number">0</span>,<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">第二页数据,一页显示<span class="number">3</span>行数据   (<span class="number">2</span><span class="number">-1</span>)<span class="operator">*</span><span class="number">3</span>,<span class="number">3</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tablename limit <span class="number">3</span>,<span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<h3 id="分页查询前端需要传递两个参数"><a href="#分页查询前端需要传递两个参数" class="headerlink" title="分页查询前端需要传递两个参数"></a>分页查询前端需要传递两个参数</h3><p>1、pageNo，因为点第几页是用户决定的。所以需要传参数。</p>
<p>2、pageSize，因为用户可选每页展示条数(如10，20，50等)(其实如果固定分页大小的话,这个参数可以不传)</p>
<p>对应limit start,count</p>
<h2 id="4-Mapper-层代码的编写-Mapper"><a href="#4-Mapper-层代码的编写-Mapper" class="headerlink" title="4.Mapper 层代码的编写@Mapper"></a>4.Mapper 层代码的编写@Mapper</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span> </span><br><span class="line">Public <span class="keyword">interface</span> <span class="title class_">UserMapper</span>&#123; </span><br><span class="line">    <span class="meta">@Select(“xxxxx”)</span> </span><br><span class="line">    Public List <span class="title function_">listAll</span><span class="params">()</span>; </span><br><span class="line">    Public List <span class="title function_">findByName</span><span class="params">(<span class="meta">@Param(“username”)</span> String username)</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接收参数 </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">as</span> u <span class="keyword">where</span> u.name<span class="operator">=</span>#&#123;username&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-Mybatis-整合的两种方式"><a href="#5-Mybatis-整合的两种方式" class="headerlink" title="5.Mybatis 整合的两种方式"></a>5.Mybatis 整合的两种方式</h2><h3 id="基于注解-1"><a href="#基于注解-1" class="headerlink" title="基于注解"></a>基于注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**   根据id查询对象   */</span></span><br><span class="line"><span class="meta">@Select(&quot;select * from teacher where id=#&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Teacher <span class="title function_">getById</span><span class="params">(<span class="type">long</span> id)</span>;</span><br><span class="line">  <span class="comment">/** 查询所有   */</span></span><br><span class="line"><span class="meta">@Select(&quot;select * from teacher&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Teacher&gt; <span class="title function_">listAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** * 更新   */</span></span><br><span class="line"><span class="meta">@Update(&quot;update teacher set name=#&#123;name&#125;,office=#&#123;office&#125;,age=#&#123;age&#125;,email=#&#123;email&#125;, &quot; + &quot; cellphone=#&#123;cellphone&quot; +            &quot;&#125;, professional_title=#&#123;professionalTitle&#125;  where id=#&#123;id&#125; &quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(Teacher teacher)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 删除   */</span></span><br><span class="line"><span class="meta">@Delete(&quot;delete from teacher where id=#&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteById</span><span class="params">(<span class="type">long</span> id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**  新增   */</span></span><br><span class="line"><span class="meta">@Insert(&quot;insert into teacher(name,office,age,email, cellphone,professional_title) values(#&#123;name&#125;,#&#123;office&#125;,&quot; + &quot; &quot; + &quot;#&#123;age&#125;, #&#123;email&#125;, #&#123;cellphone&#125;,  #&#123;professionalTitle&#125;)&quot;)</span></span><br><span class="line"><span class="meta">@Options(useGeneratedKeys = true, keyColumn = &quot;id&quot;, keyProperty = &quot;id&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(Teacher teacher)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为了获取新记录的主键，需要将属性useGeneratedKeys设置为 true,同时设置keyColumn(对应数据表主键字段)和 keyProperty(对象的主键属性)。新增主键值将回填到teacher对象中</p>
</blockquote>
<h3 id="基于XML映射文件"><a href="#基于XML映射文件" class="headerlink" title="基于XML映射文件"></a>基于XML映射文件</h3><p>在映射文件中，<mapper>元素是映射文件的根元素，其他元素都是它的子元素。 </p>
<p><img src="/2023/06/20/javaEE%E6%80%BB%E7%BB%93/image-20230619155137039.png" alt="image-20230619155137039"></p>
<p>xml映射文件通常放在resouces目录下的mapper文件夹中。内容构造如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- namespace表示命名空间 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.javaee.ch09mybatis.crud.mapper.StudentMapper&quot;</span>&gt;</span></span><br><span class="line">编写接口方法的具体实现</span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line">            select * from  student where  id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;add&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyColumn</span>=<span class="string">&quot;id&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">    insert  into student(student_no,name,home_address,class_no, sex, birthday, </span><br><span class="line">enroll_time)</span><br><span class="line">    values(#&#123;studentNo&#125;,#&#123;name&#125;,#&#123;homeAddress&#125;,#&#123;classNo&#125;,#&#123;sex&#125;, #&#123;birthday&#125;, </span><br><span class="line">#&#123;enrollTime&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;listAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.javaee.ch09mybatis.crud.entity.Student&quot;</span>&gt;</span></span><br><span class="line">    select  * from student</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findLikeName&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">resultType</span>=<span class="string">&quot;com.javaee.ch09mybatis.crud.entity.Student&quot;</span>&gt;</span></span><br><span class="line">    select * from student where name like CONCAT(&#x27;%&#x27;, #&#123;name&#125;, &#x27;%&#x27;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span>&gt;</span></span><br><span class="line">      update   student set student_no=#&#123;studentNo&#125;,  name=#</span><br><span class="line">&#123;name&#125;,home_address=#&#123;homeAddress&#125;,</span><br><span class="line">      class_no=#&#123;classNo&#125;, sex=#&#123;sex&#125;, birthday=#&#123;birthday&#125;, enroll_time=#</span><br><span class="line">&#123;enrollTime&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteById&quot;</span>&gt;</span></span><br><span class="line">    delete from student where  id =#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="6-Mybatis-接口的传参"><a href="#6-Mybatis-接口的传参" class="headerlink" title="6.Mybatis 接口的传参"></a>6.Mybatis 接口的传参</h2><h3 id="1-单个参数传递"><a href="#1-单个参数传递" class="headerlink" title="1. 单个参数传递"></a>1. 单个参数传递</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在接口中定义放法，参数形式如下</span></span><br><span class="line"><span class="comment">//使用单个参数</span></span><br><span class="line">Student <span class="title function_">selectById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    使用单个参数查询：</span></span><br><span class="line"><span class="comment">    parameterType：表示参数数据类型（可不写）</span></span><br><span class="line"><span class="comment">    使用  #&#123;参数名&#125; 获取参数的值</span></span><br><span class="line"><span class="comment">    对参数名称无要求</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;cn.krain.domain.Student&quot;</span>&gt;</span></span><br><span class="line">    select * from student where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用方法时只需要传入相应类型的单个值即可</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> dao.selectById(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h3 id="2-使用-param为参数命名传递多个参数"><a href="#2-使用-param为参数命名传递多个参数" class="headerlink" title="2. 使用@param为参数命名传递多个参数"></a>2. 使用@param为参数命名传递多个参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  在接口文件的对应方法形参中，使用以下格式进行命名</span></span><br><span class="line"><span class="comment">*   多个参数：为参数命名，在形参前加上  @Param(&quot;自定义参数名&quot;)</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">List&lt;Student&gt; <span class="title function_">selectMultiParam</span><span class="params">(<span class="meta">@Param(&quot;myname&quot;)</span> String name,</span></span><br><span class="line"><span class="params">                                <span class="meta">@Param(&quot;myage&quot;)</span> Integer age)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用时传入对应的参数值</span></span><br><span class="line">List&lt;Student&gt; students = dao.selectMultiParam(<span class="string">&quot;康康&quot;</span>,<span class="number">23</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    多个参数：使用param命名 使用为参数起得名称 eg：#&#123;命名&#125;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectMultiParam&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;cn.krain.domain.Student&quot;</span>&gt;</span></span><br><span class="line">    select * from student where name=#&#123;myname&#125; or age=#&#123;myage&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-使用Java对象作为方法的参数"><a href="#3-使用Java对象作为方法的参数" class="headerlink" title="3. 使用Java对象作为方法的参数"></a>3. 使用Java对象作为方法的参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在接口中定义方法，参数形式如下</span></span><br><span class="line"><span class="comment">//多个参数：使用java对象作为方法的参数</span></span><br><span class="line">List&lt;Student&gt; <span class="title function_">selectMultiObject</span><span class="params">(QueryParam queryParam)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    多个参数：使用java对象的属性值作为参数实际值</span></span><br><span class="line"><span class="comment">    原始语法：#&#123;属性名, javaType=java中类型名称, jdbcType=数据库中的类型名&#125;</span></span><br><span class="line"><span class="comment">    eg:  #&#123;queryName, javaType=String, jdbcType=Varchar&#125;</span></span><br><span class="line"><span class="comment">        #&#123;queryAge, javaType=Integer, jdbcType=Integer&#125;</span></span><br><span class="line"><span class="comment">    简写：#&#123;属性名&#125;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectMultiObject&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;cn.krain.domain.Student&quot;</span>&gt;</span></span><br><span class="line">    select * from student where name=#&#123;queryName&#125; or age=#&#123;queryAge&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用时传入相应对象</span></span><br><span class="line">List&lt;Student&gt; students = dao.selectMultiObject(queryParam);</span><br></pre></td></tr></table></figure>



<h3 id="4-使用位置传参"><a href="#4-使用位置传参" class="headerlink" title="4. 使用位置传参"></a>4. 使用位置传参</h3><p>  在方法的参数中，形参的顺序对应映射文件中参数的顺序，arg0指形参中第一个值，arg1代表第二个，以此类推。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在接口中定义放法，参数形式如下</span></span><br><span class="line"><span class="comment">//多个参数：使用位置传参</span></span><br><span class="line">List&lt;Student&gt; <span class="title function_">selectMultiPosition</span><span class="params">(String name, Integer age)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--根据参数位置传参    arg后面的数字代表参数所在的位置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectMultiPosition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;cn.krain.domain.Student&quot;</span>&gt;</span></span><br><span class="line">    select * from student where name=#&#123;arg0&#125; or age=#&#123;arg1&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用代码</span></span><br><span class="line">List&lt;Student&gt; students = dao.selectMultiPosition(<span class="string">&quot;康康&quot;</span>, <span class="number">23</span>);</span><br></pre></td></tr></table></figure>



<h3 id="5-使用map传参"><a href="#5-使用map传参" class="headerlink" title="5. 使用map传参"></a>5. 使用map传参</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在接口中定义放法，参数形式如下</span></span><br><span class="line"><span class="comment">//使用Map传递多个参数</span></span><br><span class="line">List&lt;Student&gt; <span class="title function_">selectMultiMap</span><span class="params">(Map&lt;String, Object&gt; map)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--使用Map键值对传参，形式：#&#123;key名&#125;--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectMultiMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;cn.krain.domain.Student&quot;</span>&gt;</span></span><br><span class="line">    select * from student where name=#&#123;mapName&#125; or age=#&#123;mapAge&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用</span></span><br><span class="line">Map&lt;String,Object&gt; data = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Object&gt;();</span><br><span class="line">data.put(<span class="string">&quot;mapName&quot;</span>,<span class="string">&quot;krain&quot;</span>);</span><br><span class="line">data.put(<span class="string">&quot;mapAge&quot;</span>,<span class="number">23</span>);</span><br><span class="line">List&lt;Student&gt; students = dao.selectMultiMap(data);</span><br></pre></td></tr></table></figure>

<h2 id="7-基于mybatis的模糊查询"><a href="#7-基于mybatis的模糊查询" class="headerlink" title="7.基于mybatis的模糊查询"></a>7.基于mybatis的模糊查询</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;fuzzyQuery&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.bin.pojo.Book&quot;</span>&gt;</span></span><br><span class="line">    select * from mybatis.book where bookName like concat(&#x27;%&#x27;,#&#123;info&#125;,&#x27;%&#x27;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>like concat关键字</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;fuzzyQuery&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.bin.pojo.Book&quot;</span>&gt;</span></span><br><span class="line">    select * from mybatis.book where bookName like &#x27;%#&#123;info&#125;%&#x27;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="8-基于Mybatis的动态多条件查询"><a href="#8-基于Mybatis的动态多条件查询" class="headerlink" title="8.基于Mybatis的动态多条件查询"></a>8.基于Mybatis的动态多条件查询</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByNameAndClassNo&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">resultType</span>=<span class="string">&quot;com.javaee.ch09mybatis.crud.entity.Student&quot;</span>&gt;</span></span><br><span class="line">    select * from student where 1=1</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name!=null&quot;</span>&gt;</span></span><br><span class="line">        and name like CONCAT(&#x27;%&#x27;, #&#123;name&#125;, &#x27;%&#x27;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;classNo!=null&quot;</span>&gt;</span></span><br><span class="line">        and class_no like CONCAT(&#x27;%&#x27;, #&#123;classNo&#125;, &#x27;%&#x27;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>where 1&#x3D;1</strong>⽤于保证SQL语法正确性。如果没有添加1&#x3D;1，则当name和home_address都为空时， SQL语句将变为 <code>select * from student where</code>,成为⼀个⾮法的SQL语句。</p>
<h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><p>使⽤“where”标签会根据它包含的标签中是否有返回值，进⾏‘where’关键词的插⼊。另外，如果标签返回的内容 是以AND 或OR 开头的，则会删除。使⽤where标签之后将不在需要之前的1&#x3D;1的条件，上述联合查询功能使⽤ where标签实现的具体代码如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByNameAndClassNo&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">resultType</span>=<span class="string">&quot;com.javaee.ch09mybatis.crud.entity.Student&quot;</span>&gt;</span></span><br><span class="line">    select * from student</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name!=null and name!=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            and name like CONCAT(&#x27;%&#x27;, #&#123;name&#125;, &#x27;%&#x27;)</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;classNo!=null and classNo!=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            and class_no like CONCAT(&#x27;%&#x27;, #&#123;classNo&#125;, &#x27;%&#x27;)</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>Set标签⽤于动态更新语句。set 元素可以⽤于动态包含需要更新的列，忽略其它不更新的列。例如，程序只需要更 新student⾮空的属性值，mapper接⼝类代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">updateIfExists</span><span class="params">(Student student)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateIfExists&quot;</span>&gt;</span></span><br><span class="line">    update student</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;studentNo !=null and !=&#x27;&#x27;&quot;</span>&gt;</span>student_no=#&#123;studentNo&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name !=null and !=&#x27;&#x27;&quot;</span>&gt;</span>name=#&#123;name&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;homeAddress !=null and !=&#x27;&#x27;&quot;</span>&gt;</span>home_address=#&#123;homeAddress&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;classNo !=null and !=&#x27;&#x27;&quot;</span>&gt;</span>class_no=#&#123;classNo&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex !=null&quot;</span>&gt;</span>sex=#&#123;sex&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age !=null and age&gt;0&quot;</span>&gt;</span>age=#&#123;age&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;birthday !=null&quot;</span>&gt;</span>birthday=#&#123;birthday&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;enrollTime !=null&quot;</span>&gt;</span>enroll_time=#&#123;enrollTime&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><p>批量操作是数据操作常常碰到的情景，例如要导⼊⼀个excel⽂件记录到数据中，往往需要使⽤批量插⼊的⽅式来 提⾼效率，同时，批量删除和其他的批量处理也是业务中经常碰到的操作。此时，可以foreach标签来实现批量操 作。foreach可以遍历指定集合，动态构造所需的 SQL语句。。⽐如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectPostIn&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;domain.blog.Post&quot;</span>&gt;</span></span><br><span class="line">  SELECT *</span><br><span class="line">  FROM POST P</span><br><span class="line">  WHERE ID in</span><br><span class="line">  <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">index</span>=<span class="string">&quot;index&quot;</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">        #&#123;item&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>foreach 元素的功能⾮常强⼤，它允许你指定⼀个集合，声明可以在元素体内使⽤的集合项（item）和索引 （index）变量。它也允许你指定开头与结尾的字符串以及集合项迭代之间的分隔符。这个元素也不会错误地添加 多余的分隔符，看它多智能！</p>
<p> 提示 : 你可以将任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象作为集合参数传递给 foreach。当使 ⽤可迭代对象或者数组时，index 是当前迭代的序号，item 的值是本次迭代获取到的元素。当使⽤ Map 对象（或 者 Map.Entry 对象的集合）时，index 是键，item 是值。</p>
<p><strong>批量插⼊数据：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**批量插⼊*/</span></span><br><span class="line"> <span class="keyword">public</span>  <span class="type">int</span> <span class="title function_">batchInsert</span><span class="params">(List&lt;Student&gt; list)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    批量插⼊--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;batchInsert&quot;</span>  <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyColumn</span>=<span class="string">&quot;id&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">     insert  into student(student_no,name,home_address,class_no, sex, birthday, </span><br><span class="line">enroll_time) values</span><br><span class="line"><span class="comment">&lt;!--        collcetion对应集合名称, item对应集合元素, separator表示分隔符--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">item</span>=<span class="string">&quot;s&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">          (#&#123;s.studentNo&#125;,#&#123;s.name&#125;,#&#123;s.homeAddress&#125;,#&#123;s.classNo&#125;,#&#123;s.sex&#125;, #</span><br><span class="line">    &#123;s.birthday&#125;, #&#123;s.enrollTime&#125;)</span><br><span class="line">     <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意：和insert插⼊操作⼀样，需要使⽤useGeneratedKeys属性值才能获得主键id并回填到对象</p>
<p><strong>批量删除</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**批量删除*/</span></span><br><span class="line"><span class="keyword">public</span>  <span class="type">int</span> <span class="title function_">batchDelete</span><span class="params">(List&lt;Student&gt; list)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--批量删除--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;batchDelete&quot;</span>&gt;</span></span><br><span class="line">    delete  from  student where id in (</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">item</span>=<span class="string">&quot;student&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> &gt;</span></span><br><span class="line">        #&#123;student.id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    )</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="SQL⽚段-sql"><a href="#SQL⽚段-sql" class="headerlink" title="SQL⽚段 sql"></a>SQL⽚段 sql</h3><p>有时候可能某个 sql 语句我们⽤的特别多，为了增加代码的重⽤性，简化代码，我们需要将这些代码抽取出来，然 后使⽤时直接调⽤。代码⽚段的使⽤分为代码⽚段定义和使⽤两部分。</p>
<p>定义⽚段</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;selectall&quot;</span>&gt;</span></span><br><span class="line">	select id,class_no,student_no,name from student</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使⽤⽚段</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectStudent&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;selectall&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="script"><a href="#script" class="headerlink" title="script"></a>script</h3><p>要在带注解的映射器接⼝类中使⽤动态 SQL，可以使⽤ script 元素。⽐如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Update(&#123;&quot;&lt;script&gt;&quot;,</span></span><br><span class="line"><span class="meta"> &quot;update Author&quot;,</span></span><br><span class="line"><span class="meta"> &quot;  &lt;set&gt;&quot;,</span></span><br><span class="line"><span class="meta"> &quot;    &lt;if test=&#x27;username != null&#x27;&gt;username=#&#123;username&#125;,&lt;/if&gt;&quot;,</span></span><br><span class="line"><span class="meta"> &quot;    &lt;if test=&#x27;password != null&#x27;&gt;password=#&#123;password&#125;,&lt;/if&gt;&quot;,</span></span><br><span class="line"><span class="meta"> &quot;    &lt;if test=&#x27;email != null&#x27;&gt;email=#&#123;email&#125;,&lt;/if&gt;&quot;,</span></span><br><span class="line"><span class="meta"> &quot;    &lt;if test=&#x27;bio != null&#x27;&gt;bio=#&#123;bio&#125;&lt;/if&gt;&quot;,</span></span><br><span class="line"><span class="meta"> &quot;  &lt;/set&gt;&quot;,</span></span><br><span class="line"><span class="meta"> &quot;where id=#&#123;id&#125;&quot;,</span></span><br><span class="line"><span class="meta"> &quot;&lt;/script&gt;&quot;&#125;)</span></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">updateAuthorValues</span><span class="params">(Author author)</span></span><br></pre></td></tr></table></figure>

<h2 id="9-Mybatis-plus"><a href="#9-Mybatis-plus" class="headerlink" title="9.Mybatis-plus"></a>9.Mybatis-plus</h2><p>MyBatis-Plus (opens new window)（简称 MP）是一个 MyBatis (opens new window)的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p>
<p><strong>特性</strong></p>
<ul>
<li><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</li>
<li><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</li>
<li><strong>强大的 CRUD 操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</li>
<li><strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</li>
<li><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</li>
<li><strong>支持 ActiveRecord 模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</li>
<li><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</li>
<li><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</li>
<li><strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</li>
<li><strong>分页插件支持多种数据库</strong>：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库</li>
<li><strong>内置性能分析插件</strong>：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</li>
<li><strong>内置全局拦截插件</strong>：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作</li>
</ul>
<h2 id="10-对象关联关系"><a href="#10-对象关联关系" class="headerlink" title="10.对象关联关系"></a>10.对象关联关系</h2><p><img src="/2023/06/20/javaEE%E6%80%BB%E7%BB%93/clip_image002.png" alt="img"></p>
<p><strong>一对一</strong></p>
<ul>
<li>主键共享<br>两张表的主键，建立外键约束。</li>
<li>外键唯一<br>子表添加一个新的字段并给该字段添加唯一约束和外键约束，然后关联父表主键字段。</li>
</ul>
<p><strong>一对多</strong></p>
<ul>
<li>外键添加在多的一方，关联一的主键。</li>
</ul>
<p> <strong>多对多</strong></p>
<ul>
<li>中间表：<strong>创建一个中间表，中间表的两个普通字段分别关联另两张表的主键。</strong></li>
</ul>
<h1 id="七-Redis-缓存和RabbitMQ"><a href="#七-Redis-缓存和RabbitMQ" class="headerlink" title="七. Redis 缓存和RabbitMQ"></a>七. Redis 缓存和RabbitMQ</h1><h2 id="1-Redis"><a href="#1-Redis" class="headerlink" title="1.Redis"></a>1.Redis</h2><p>Redis 完全是基于内存的操作，所以很快。还有因为key-value结构简单。是一个高性能的key-value非关系型数据库</p>
<h3 id="端口号6379"><a href="#端口号6379" class="headerlink" title="端口号6379"></a>端口号6379</h3><h3 id="redis的实现原理"><a href="#redis的实现原理" class="headerlink" title="redis的实现原理"></a>redis的实现原理</h3><ol>
<li>内存存储：Redis 将数据存储在主内存中，以实现高速的读写操作。它使用自己的内存分配器，对内存进行高效管理，并通过哈希表等数据结构提供快速的数据访问。</li>
<li>单线程模型：Redis 采用单线程模型来处理客户端的请求。这是因为 Redis 的瓶颈通常在于 CPU 的处理能力，而不是线程的并发性。单线程模型简化了数据结构的实现和锁的管理，并减少了线程切换的开销。</li>
<li>基于事件驱动的异步 I&#x2F;O：Redis 使用事件驱动的网络模型来处理客户端请求和网络通信。它使用 epoll 或 kqueue 等操作系统提供的机制监听网络事件，一旦有事件发生，就会触发相应的回调函数进行处理。这种异步的 I&#x2F;O 模型使得 Redis 能够支持高并发的网络连接。</li>
<li>持久化机制：Redis 提供了两种持久化机制，即快照（snapshotting）和日志（append-only file）。快照通过将数据集的副本写入磁盘，以恢复数据集的状态。日志记录了写操作的命令，通过回放日志来还原数据集。这两种机制可以单独或同时使用，以满足不同的需求。</li>
<li>命令的原子性：Redis 的命令是原子性的，即每个命令要么完全执行，要么完全不执行。它使用事务和乐观锁机制来保证多个命令的原子性操作。事务通过将一组命令打包在一个单独的步骤中执行，而乐观锁则在执行命令之前检查数据是否被其他客户端修改。</li>
<li>高可用性和复制：Redis 支持主从复制机制，可以将一个 Redis 服务器配置为主服务器，而其他服务器作为从服务器进行复制。主服务器负责处理写操作，从服务器负责复制主服务器的数据并处理读操作。这样可以提高系统的可用性和容错性。</li>
</ol>
<h3 id="redis整合Springboot主要注解"><a href="#redis整合Springboot主要注解" class="headerlink" title="redis整合Springboot主要注解"></a>redis整合Springboot主要注解</h3><p><strong>@EnableCache</strong> 开启基于注解的缓存功能</p>
<p><strong>@Cacheable</strong>注解 ：<strong>先从redis数据库中 按照当前key查找，有没有。如果redis中有，是不会走当前该方法的，如果没有再调用方法返回结果，如果结果不为null将其缓存到数据库中（一般用于find）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Cacheable(cacheNames=&quot;teacher&quot;,unless=&quot;#result ==null&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Teacher <span class="title function_">getById</span><span class="params">(Serialzable id)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.getById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>@CachePut:</strong> 主要用于向数据库中插入数据，向数据中插入数据的时候，会将返回的int类型，放入redis中缓存，当然是有选择性的(一般用于insert)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CachePut(cacheNames=&quot;teacher&quot;,key=&quot;#result.id&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Teacher <span class="title function_">update</span><span class="params">(Teacher teacher)</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">this</span>.updateById(teacher))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getById(teacher.getId());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>@CacheEvict</strong>：满足条件则移除当前key在redis中的数据（一般用于update&#x2F;delete）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CacheEvict(cacheNames=&quot;teacher&quot;,unless=&quot;#result ==null&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeById</span><span class="params">(Serialzable id)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.removeById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Redis实现和数据库的数据一致性"><a href="#Redis实现和数据库的数据一致性" class="headerlink" title="Redis实现和数据库的数据一致性"></a>Redis实现和数据库的数据一致性</h3><ol>
<li><strong>读写分离</strong>：通过将数据库的读操作和写操作分别路由到不同的实例或节点，可以实现读写分离。写操作可以直接写入数据库，而读操作则可以从Redis中获取数据，从而实现数据库与Redis之间的数据一致性。</li>
<li>延迟双写：在写入数据库之前，先将数据写入Redis。然后，通过异步方式将数据写入数据库，可以减少写入数据库的频率，提高系统的性能。虽然在写入数据库之前存在一定的延迟，但通过合理的设计和配置，可以确保数据的最终一致性。</li>
<li>事务和队列：Redis支持事务（Transaction）和消息队列（Message Queue），可以将数据库的写操作和Redis的写操作放入同一个事务中或者将写操作作为消息放入队列中。通过事务或队列的机制，可以确保数据库和Redis中的写操作要么同时成功，要么同时失败，从而实现数据的一致性。</li>
<li>缓存更新策略：当数据库中的数据发生变化时，需要及时更新Redis中的缓存数据。可以采用主动更新（Active Updating）或被动更新（Passive Updating）策略。主动更新是在数据库数据变化时主动触发更新Redis缓存，而被动更新是在Redis缓存被访问时检查数据是否过期，过期则重新从数据库加载。这些策略可以根据具体场景和需求进行选择和调整。</li>
<li>数据同步和复制：如果需要在多个Redis节点之间实现数据一致性，可以使用Redis的复制机制。通过将一个Redis节点配置为主节点，而其他节点配置为从节点，主节点负责处理写操作并将数据复制到从节点。这样可以确保主节点和从节点之间的数据一致性。</li>
</ol>
<h2 id="2-rabbitMQ"><a href="#2-rabbitMQ" class="headerlink" title="2.rabbitMQ"></a>2.rabbitMQ</h2><p>RabbitMQ是一个由erlang开发的AMQP（Advanced Message Queue 高级消息队列协议 ）的开源实现，能够实现异步消息处理       </p>
<p>rabbitMQ是一个消息代理：它接受和转发消息。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol>
<li>异步处理</li>
<li>应用解耦</li>
<li>流量削峰</li>
<li>分布式事务管理</li>
</ol>
<h3 id="网页客户端端口号：15672"><a href="#网页客户端端口号：15672" class="headerlink" title="网页客户端端口号：15672"></a>网页客户端端口号：15672</h3><h3 id="配置端口号：5672"><a href="#配置端口号：5672" class="headerlink" title="配置端口号：5672"></a>配置端口号：5672</h3><h3 id="rabbitMQ的几个概念"><a href="#rabbitMQ的几个概念" class="headerlink" title="rabbitMQ的几个概念"></a>rabbitMQ的几个概念</h3><ol>
<li>交换器（Exchanges）：交换器是消息的发布者发送消息的地方。它接收来自生产者的消息并将其路由到一个或多个队列。交换器根据定义的规则（路由键）决定消息将被发送到哪个队列。<ul>
<li><code>fanout</code>类型的交换器会将消息广播到所有绑定到该交换器的队列中。它不关心消息的路由键（routing key），只是简单地将消息发送到所有绑定的队列。</li>
<li><code>header</code>类型的交换器使用消息的header信息进行匹配，根据header的键值对来确定消息路由到哪些队列。</li>
<li><code>topic</code>类型的交换器使用模式匹配的方式将消息路由到队列。消息的路由键（routing key）和交换器的绑定键（binding key）之间使用通配符进行匹配。</li>
<li><code>direct</code>类型的交换器根据消息的路由键（routing key）和交换器的绑定键（binding key）进行精确匹配，将消息路由到指定的队列。</li>
</ul>
</li>
<li>队列（Queues）：队列是RabbitMQ中的消息容器，它存储等待被消费者处理的消息。当消息被发送到队列时，它们会被保存在队列中直到被消费者接收。消费者可以按照顺序接收队列中的消息。</li>
<li>消息确认（Message Acknowledgment）：消息确认是一种机制，用于确认消息已被消费者接收和处理。当消息被消费者处理后，它可以发送一个确认给RabbitMQ，告知它可以删除该消息。</li>
</ol>
<h3 id="rabbitMQ的工作模式"><a href="#rabbitMQ的工作模式" class="headerlink" title="rabbitMQ的工作模式"></a>rabbitMQ的工作模式</h3><ol>
<li>简单模式（Simple Mode）：在简单模式下，一个生产者向一个队列发送消息，一个消费者从该队列接收并处理消息。这是最基本的模式，适用于单个生产者和单个消费者的情况。</li>
<li>工作队列模式（Work Queue Mode）：在工作队列模式下，一个生产者向一个队列发送消息，多个消费者从同一个队列接收消息并进行处理。消息会被平均分配给不同的消费者，以实现负载均衡。适用于并行处理任务的场景。</li>
<li>发布-订阅模式（Publish-Subscribe Mode）：在发布-订阅模式下，一个生产者发送消息到一个交换器，交换器将消息广播给绑定到它的所有队列。每个队列都有自己的消费者，它们独立地接收并处理消息。适用于需要将消息广播给多个消费者的场景。</li>
<li>路由模式（Routing Mode）：在路由模式下，生产者发送带有路由键的消息到交换器，交换器根据路由键将消息发送到与之匹配的队列。每个队列都有自己的消费者，它们只接收与队列绑定的特定路由键匹配的消息。适用于根据不同的消息内容将消息分发给不同的消费者的场景。</li>
<li>主题模式（Topic Mode）：主题模式是路由模式的扩展，它允许使用通配符匹配路由键。生产者发送带有特定主题的消息到交换器，消费者可以使用通配符模式订阅特定的主题，只接收与订阅主题匹配的消息。适用于根据复杂的主题匹配规则进行灵活消息过滤和路由的场景。</li>
</ol>
<h3 id="常用的消息队列中间件"><a href="#常用的消息队列中间件" class="headerlink" title="常用的消息队列中间件"></a>常用的消息队列中间件</h3><p>RocketMQ-Erlang语言</p>
<p>RocketMQ-阿里 Java语言，设计时参考了Kafka，消息可靠性上比Kafka更好</p>
<p>ActiveMQ-Apache</p>
<p>Kafka</p>
<h1 id="八-任务管理"><a href="#八-任务管理" class="headerlink" title="八. 任务管理"></a>八. 任务管理</h1><h2 id="cron时间表达式"><a href="#cron时间表达式" class="headerlink" title="cron时间表达式"></a>cron时间表达式</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;Seconds&#125; &#123;Minutes&#125; &#123;Hours&#125; &#123;DayofMonth&#125; &#123;Month&#125; &#123;DayofWeek&#125; &#123;Year&#125;或</span><br><span class="line">&#123;Seconds&#125; &#123;Minutes&#125; &#123;Hours&#125; &#123;DayofMonth&#125; &#123;Month&#125; &#123;DayofWeek&#125;</span><br></pre></td></tr></table></figure>

<h1 id="九-Java-EE后端分层设计"><a href="#九-Java-EE后端分层设计" class="headerlink" title="九. Java EE后端分层设计"></a>九. Java EE后端分层设计</h1><h2 id="MVC设计模式流程"><a href="#MVC设计模式流程" class="headerlink" title="MVC设计模式流程"></a>MVC设计模式流程</h2><p><img src="/2023/06/20/javaEE%E6%80%BB%E7%BB%93/295ddcc75ad2c2f7f9bfea66992216dc.png" alt="img"></p>
<p>（1）用户发起HTTP请求；</p>
<p>（2）Web服务器接收到请求后，根据请求的url地址将请求转发到相应的servlet进行处理。注意：控制器是和用户交互的接口；</p>
<p>（3）Servlet获取用户请求的相关参数，并根据用户的请求调用模型层相应操作接口；</p>
<p>（4）模型层调用数据库查询接口，进行数据查询；</p>
<p>（5）数据库返回相关的查询结果；</p>
<p>（6）模型层对相应的查询结果进行处理，并返回给控制器；</p>
<p>（7）控制器将封装好的查询结果传递给视图页面；</p>
<p>（8）视图页面获取查询结果，并进行页面渲染输出。</p>
<h2 id="前后端分离模式特点，和传统后端渲染模式的区别"><a href="#前后端分离模式特点，和传统后端渲染模式的区别" class="headerlink" title="前后端分离模式特点，和传统后端渲染模式的区别"></a>前后端分离模式特点，和传统后端渲染模式的区别</h2><p>前后端分离模式和传统后端渲染模式是两种不同的架构方式，它们有以下特点和区别：</p>
<p>前后端分离模式的特点：</p>
<ol>
<li>前后端分离：前后端分离模式将前端和后端开发分离，前端负责用户界面和交互逻辑，后端负责数据处理和业务逻辑。</li>
<li>API通信：前后端通过API进行通信，前端通过调用后端提供的API来获取数据和执行业务逻辑。</li>
<li>前端框架：前后端分离模式通常使用前端框架（如React、Angular、Vue.js）来构建交互式用户界面。</li>
<li>前端渲染：前端负责将获取到的数据进行渲染和展示，可以通过AJAX或Fetch等技术从后端异步获取数据，并使用JavaScript在客户端进行渲染。</li>
</ol>
<p>传统后端渲染模式的特点：</p>
<ol>
<li>后端渲染：传统后端渲染模式是指后端负责渲染生成完整的HTML页面，并将页面直接发送给客户端浏览器进行展示。</li>
<li>页面刷新：在传统后端渲染模式下，当用户与页面交互或请求新的内容时，通常需要进行整个页面的刷新，后端重新渲染页面并返回给客户端。</li>
<li>多页面应用：传统后端渲染模式通常适用于多页面应用（Multi-Page Application，MPA），每个页面由后端负责生成和渲染。</li>
<li>服务器负担：由于后端需要处理页面的渲染和请求响应，服务器的负担较重。</li>
</ol>
<p>区别：</p>
<ol>
<li>前后端分离模式将前端和后端分开，前端负责渲染和交互逻辑，后端提供API和数据服务；传统后端渲染模式中后端负责渲染生成完整的HTML页面。</li>
<li>前后端分离模式通过API进行通信，实现异步数据交互，只更新部分页面内容；传统后端渲染模式需要进行整个页面的刷新，导致网络开销较大。</li>
<li>前后端分离模式使用前端框架构建交互式用户界面，页面渲染由前端处理；传统后端渲染模式页面渲染由后端负责。</li>
<li>前后端分离模式适用于单页面应用（Single-Page Application，SPA）和多页面应用（Multi-Page Application，MPA）；传统后端渲染模式主要适用于MPA。</li>
</ol>
<p>前后端分离模式具有更好的灵活性和可维护性，前后端开发团队可以独立进行工作，并且前端可以使用现代化的技术栈构建交互式的用户界面。传统后端渲染模式在某些情况下可能更适用，特别是对于较为传统的多页面应用。选择哪种模式取决于具体的项目需求和技术栈。</p>
<h2 id="Service、-Transactional"><a href="#Service、-Transactional" class="headerlink" title="@Service、@Transactional"></a>@Service、@Transactional</h2><p>@Service和@Transactional是Spring框架中的注解，用于在应用程序中提供特定的功能和行为。</p>
<ol>
<li><p>@Service注解：@Service注解标记一个类为服务层组件，表示该类用于处理业务逻辑。它通常与@Autowired注解一起使用，将服务类对象注入到其他组件中。@Service注解帮助组织代码，使得代码结构更加清晰，并且方便进行依赖注入和组件扫描。</p>
</li>
<li><p>@Transactional注解：@Transactional注解用于控制事务的行为，用于确保在方法执行期间的数据库操作要么完全成功，要么完全失败（回滚）。它可以在方法级别或类级别上使用。当一个方法或类被标记为@Transactional时，Spring会创建一个事务边界，并确保在方法执行期间的数据库操作遵循事务的ACID特性（原子性、一致性、隔离性和持久性）。</p>
</li>
</ol>
<p>@Transactional注解提供了以下功能：</p>
<ul>
<li>自动地创建和管理事务。</li>
<li>当方法执行时，会自动启动事务，并在方法结束时提交事务或回滚事务（根据方法的执行结果）。</li>
<li>可以设置事务的隔离级别、传播行为、只读属性等。</li>
</ul>
<p>使用@Transactional注解可以确保数据库操作的一致性和完整性，并简化了事务管理的代码。它在与持久层框架（如Spring Data JPA、Hibernate）一起使用时，可以自动处理数据库事务，减少手动事务管理的工作量。</p>
<h2 id="设计的基本概念DTO、VO的作用"><a href="#设计的基本概念DTO、VO的作用" class="headerlink" title="设计的基本概念DTO、VO的作用"></a>设计的基本概念DTO、VO的作用</h2><p>DTO（Data Transfer Object）和VO（Value Object）是常见的设计模式，用于在不同层之间传输数据和封装数据。</p>
<p>DTO（数据传输对象）：</p>
<ul>
<li>DTO用于在不同层（如应用层、业务层和表示层）之间传输数据，通常用于解耦和减少网络通信的数据量。</li>
<li>DTO对象通常是轻量级的，只包含数据的属性以及相应的getter和setter方法，不包含业务逻辑。</li>
<li>DTO对象可以根据业务需求来定义，用于将多个相关的数据字段封装在一个对象中，方便传输和处理。</li>
</ul>
<p>VO（值对象）：</p>
<ul>
<li>VO用于封装特定领域的数据，通常是从业务层中获取的数据，并用于表示层（如UI层）展示数据。</li>
<li>VO对象包含多个属性，代表一个完整的值，可以是单个值或一组相关值的组合。</li>
<li>VO对象通常是不可变的，即一旦创建就不能修改其内部状态。</li>
<li>VO对象可以根据业务需求来定义，用于封装和展示特定领域的数据，方便在表示层进行显示和操作。</li>
</ul>
<p>作用：</p>
<ol>
<li>解耦和数据传输：DTO和VO可以帮助解耦和不同层之间的数据传输，将数据从一个层传递到另一个层时，可以使用DTO或VO对象来封装数据，避免直接传递大量的数据对象或领域对象。</li>
<li>数据封装和展示：DTO和VO提供了一种封装数据的方式，可以将相关的数据字段组合成一个对象，方便传输和展示。VO对象还可以在表示层中用于展示数据，并提供一个统一的视图对象。</li>
<li>安全性和灵活性：DTO和VO对象可以根据业务需求定义，仅包含需要传输或展示的属性，可以控制数据的安全性和灵活性。</li>
<li>减少网络通信开销：通过使用DTO对象，可以减少网络通信的数据量，只传输必要的数据字段，提高系统性能和效率。</li>
</ol>
<p>总而言之，DTO和VO是在不同层之间传输和封装数据的对象，可以提高系统的灵活性、性能和安全性，同时帮助解耦不同层的依赖关系。</p>
<h1 id="十-SpringSecurity"><a href="#十-SpringSecurity" class="headerlink" title="十. SpringSecurity"></a>十. SpringSecurity</h1><p>在Spring Security中，默认的角色值必须带有”ROLE_”前缀。这是因为Spring Security在进行授权时，会自动在配置的角色前面添加”ROLE_”前缀来与用户的角色进行匹配。</p>
<h2 id="1-SpringSecurity-的两大功能"><a href="#1-SpringSecurity-的两大功能" class="headerlink" title="1.SpringSecurity 的两大功能"></a>1.SpringSecurity 的两大功能</h2><ol>
<li>认证（Authentication）：Spring Security提供了一系列的身份验证功能，用于验证用户的身份。这包括基于表单登录、基于HTTP基本认证、基于LDAP认证等多种认证方式。Spring Security可以处理用户的认证请求，验证其身份，并提供相应的机制来管理用户的凭证和身份信息。</li>
<li>授权（Authorization）：Spring Security提供了强大的授权功能，用于管理和控制用户对资源的访问权限。通过配置安全规则和访问控制策略，可以限制特定用户或角色对应用程序中受保护资源的访问。Spring Security支持基于角色的访问控制、基于表达式的访问控制、注解驱动的访问控制等多种授权方式。</li>
</ol>
<h2 id="2-认证和授权涉及到哪些数据"><a href="#2-认证和授权涉及到哪些数据" class="headerlink" title="2.认证和授权涉及到哪些数据"></a>2.认证和授权涉及到哪些数据</h2><p>认证和授权涉及到以下数据：</p>
<ol>
<li><p>用户凭证：认证涉及用户凭证的验证，包括用户名、密码、证书或其他身份验证凭证。这些凭证用于验证用户的身份。</p>
</li>
<li><p>用户身份信息：认证过程中需要访问和验证用户的身份信息，例如用户的角色、权限、个人信息等。</p>
</li>
<li><p>访问令牌（Access Token）：在一些身份验证流程中，认证成功后会生成访问令牌，该令牌用于后续的请求中进行身份验证和授权。访问令牌包含了用户的身份信息或其他相关信息，用于验证用户的权限和访问权限。</p>
</li>
<li><p>资源和操作：授权涉及到对资源（如网页、API端点、文件等）和操作（如读取、写入、删除等）的权限管理。授权规则确定了哪些用户或用户组有权访问特定的资源和执行特定的操作。</p>
</li>
<li><p>安全规则和配置：认证和授权涉及到安全规则和配置的定义。这些规则定义了身份验证的方式、授权策略、访问控制规则等。安全规则和配置用于指定如何验证用户身份和授予访问权限。</p>
</li>
</ol>
<p>以上数据在认证和授权的过程中起着重要的作用，帮助确保用户的身份验证和对资源的授权是正确且安全的。</p>
<h2 id="3-用户-角色-权限是什么关系？怎么设计数据表"><a href="#3-用户-角色-权限是什么关系？怎么设计数据表" class="headerlink" title="3.用户-角色-权限是什么关系？怎么设计数据表"></a>3.用户-角色-权限是什么关系？怎么设计数据表</h2><p>用户-角色-权限是一种常见的权限管理模型，用于管理用户与其对应的角色和权限之间的关系。</p>
<p>在这种模型中，用户（User）是系统中的具体用户实体，每个用户可以被分配一个或多个角色。角色（Role）表示一组权限的集合，可以用来定义用户所拥有的访问权限。权限（Permission）表示对系统中特定资源或操作的访问权限。</p>
<p>设计数据表来支持用户-角色-权限模型时，可以考虑以下几个表：</p>
<ol>
<li><p>用户表（User table）：包含用户的基本信息，如用户ID、用户名、密码等。</p>
</li>
<li><p>角色表（Role table）：包含角色的信息，如角色ID、角色名称等。</p>
</li>
<li><p>权限表（Permission table）：包含权限的信息，如权限ID、权限名称、资源路径等。</p>
</li>
<li><p>用户角色关联表（User-Role table）：用于建立用户与角色之间的多对多关系。可以包含用户ID和角色ID作为外键，表示用户所拥有的角色。</p>
</li>
<li><p>角色权限关联表（Role-Permission table）：用于建立角色与权限之间的多对多关系。可以包含角色ID和权限ID作为外键，表示角色所拥有的权限。</p>
</li>
</ol>
<p>这样的数据表设计模型可以使得用户、角色和权限之间的关系清晰，并支持灵活的权限管理。通过在用户表和角色表之间建立关联，可以将角色分配给用户。同时，通过在角色表和权限表之间建立关联，可以定义角色所拥有的权限。</p>
<p>在实际应用中，根据具体的需求，可能还需要考虑其他表和字段的设计，例如资源表、角色继承关系等。数据表的设计应根据具体的业务需求和系统设计进行调整，以满足系统的权限管理和安全需求。</p>
<h2 id="4-springsecurity-中，角色和权限有哪些区别"><a href="#4-springsecurity-中，角色和权限有哪些区别" class="headerlink" title="4.springsecurity 中，角色和权限有哪些区别"></a>4.springsecurity 中，角色和权限有哪些区别</h2><p>在Spring Security中，角色（Role）和权限（Permission）有以下区别：</p>
<ol>
<li><p>角色（Role）：角色代表一组权限的集合，用于对用户进行分类和授权。角色是对权限的逻辑分组，可以将具有相似权限需求的用户分配到相应的角色中。例如，一个系统可以定义角色为”ADMIN”（管理员）、”USER”（普通用户）等。</p>
</li>
<li><p>权限（Permission）：权限代表对系统中特定资源或操作的访问权限。权限是具体的授权单元，表示用户对特定资源或操作的访问权限。例如，一个系统可以定义权限为”READ_USER”（读取用户信息）、”WRITE_USER”（修改用户信息）等。</p>
</li>
</ol>
<p>区别总结：</p>
<ul>
<li>角色是对权限的逻辑分组，用于对用户进行分类和授权。</li>
<li>权限是具体的授权单元，表示用户对特定资源或操作的访问权限。</li>
<li>角色可以包含多个权限，一个用户可以分配多个角色。</li>
<li>权限是最小的授权单元，可以直接分配给用户或包含在角色中。</li>
</ul>
<p>在Spring Security中，可以使用角色和权限来进行访问控制和权限管理。角色通常在用户和权限之间建立逻辑关联，以简化权限的管理和授权过程。同时，可以使用基于角色或基于权限的访问控制策略来控制用户对资源的访问权限。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/javaEE/" rel="tag"><i class="fa fa-tag"></i> javaEE</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/04/07/cursor%E5%8F%96%E6%B6%88%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E5%8F%8A%E8%80%81%E7%89%88%E6%9C%AC/" rel="prev" title="cursor取消自动更新及老版本">
                  <i class="fa fa-chevron-left"></i> cursor取消自动更新及老版本
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/06/26/%E5%85%B3%E4%BA%8Enode%EF%BC%9Adigital-envelope-routines-unsupported/" rel="next" title="关于node：digital envelope routines::unsupported">
                  关于node：digital envelope routines::unsupported <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="SOHUCS" sid="e18dc55799ec4639f05c0404063ad9c9"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-star"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">星星</span>
</div>
<div>
<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
    var now = new Date(); 
    function createtime() { 
        var grt= new Date("04/01/2023 00:00:00");//在此处修改你的建站时间
        now.setTime(now.getTime()+250); 
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
        document.getElementById("timeDate").innerHTML = "Hello!<br>我在互联网已经游玩了 "+dnum+" 天 "; 
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
    } 
setInterval("createtime()",250);
</script>
<div class="busuanzi-count">
    <span class="post-meta-item clear-post-meta-item" id="busuanzi_container_site_uv">
      <!--<span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>-->
      一共有<span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"><i class="fa fa-spinner fa-spin"></i></span>
      </span>个人类来跟我说过
    </span>
    <span class="post-meta-item clear-post-meta-item" id="busuanzi_container_site_pv">
      <!--<span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>-->
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"><i class="fa fa-spinner fa-spin"></i></span>
      </span>次hello哦
    </span>
</div>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script class="next-config" data-name="changyan" type="application/json">{"enable":true,"appid":"cywCKVzaB","appkey":"prod_22e89563587e67ae0ff9ef9dd9332bf1","count":true}</script>
<script src="/js/third-party/comments/changyan.js"></script>

  
  <!--页面动画-->
  <script type="text/javascript" color="255,255,255" opacity='1' zIndex="-2" count="100" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
</body>
</html>
